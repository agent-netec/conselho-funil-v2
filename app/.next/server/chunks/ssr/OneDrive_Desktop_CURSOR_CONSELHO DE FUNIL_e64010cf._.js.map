{"version":3,"sources":["../../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/lucide-react/src/icons/palette.ts","../../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/resilience.ts","../../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/firestore.ts","../../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/hooks/use-user.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z',\n      key: 'e79jfc',\n    },\n  ],\n  ['circle', { cx: '13.5', cy: '6.5', r: '.5', fill: 'currentColor', key: '1okk4w' }],\n  ['circle', { cx: '17.5', cy: '10.5', r: '.5', fill: 'currentColor', key: 'f64h9f' }],\n  ['circle', { cx: '6.5', cy: '12.5', r: '.5', fill: 'currentColor', key: 'qy21gx' }],\n  ['circle', { cx: '8.5', cy: '7.5', r: '.5', fill: 'currentColor', key: 'fotxhn' }],\n];\n\n/**\n * @component @name Palette\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTIgMjJhMSAxIDAgMCAxIDAtMjAgMTAgOSAwIDAgMSAxMCA5IDUgNSAwIDAgMS01IDVoLTIuMjVhMS43NSAxLjc1IDAgMCAwLTEuNCAyLjhsLjMuNGExLjc1IDEuNzUgMCAwIDEtMS40IDIuOHoiIC8+CiAgPGNpcmNsZSBjeD0iMTMuNSIgY3k9IjYuNSIgcj0iLjUiIGZpbGw9ImN1cnJlbnRDb2xvciIgLz4KICA8Y2lyY2xlIGN4PSIxNy41IiBjeT0iMTAuNSIgcj0iLjUiIGZpbGw9ImN1cnJlbnRDb2xvciIgLz4KICA8Y2lyY2xlIGN4PSI2LjUiIGN5PSIxMi41IiByPSIuNSIgZmlsbD0iY3VycmVudENvbG9yIiAvPgogIDxjaXJjbGUgY3g9IjguNSIgY3k9IjcuNSIgcj0iLjUiIGZpbGw9ImN1cnJlbnRDb2xvciIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/palette\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Palette = createLucideIcon('palette', __iconNode);\n\nexport default Palette;\n","import { \r\n  FirestoreError,\r\n} from 'firebase/firestore';\r\n\r\n/**\r\n * Opções para a estratégia de resiliência.\r\n */\r\ninterface ResilienceOptions {\r\n  maxRetries?: number;\r\n  initialDelay?: number;\r\n  maxDelay?: number;\r\n  factor?: number;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Required<ResilienceOptions> = {\r\n  maxRetries: 3,\r\n  initialDelay: 1000,\r\n  maxDelay: 10000,\r\n  factor: 2,\r\n};\r\n\r\n/**\r\n * Erros do Firestore que são considerados transientes e seguros para tentar novamente.\r\n * Ref: https://firebase.google.com/docs/firestore/manage-data/error-handling\r\n */\r\nconst RETRYABLE_ERROR_CODES = [\r\n  'aborted',\r\n  'deadline-exceeded',\r\n  'resource-exhausted',\r\n  'unavailable',\r\n  'internal',\r\n];\r\n\r\n/**\r\n * Executa uma operação do Firestore com estratégia de retry e exponential backoff.\r\n * \r\n * @param operation - A função assíncrona que executa a operação do Firestore.\r\n * @param options - Configurações de retry.\r\n * @returns O resultado da operação.\r\n */\r\nexport async function withResilience<T>(\r\n  operation: () => Promise<T>,\r\n  options: ResilienceOptions = {}\r\n): Promise<T> {\r\n  const { maxRetries, initialDelay, maxDelay, factor } = {\r\n    ...DEFAULT_OPTIONS,\r\n    ...options,\r\n  };\r\n\r\n  let lastError: any;\r\n  let delay = initialDelay;\r\n\r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await operation();\r\n    } catch (error: any) {\r\n      lastError = error;\r\n\r\n      // Verifica se o erro é transiente\r\n      const isRetryable = error instanceof FirestoreError && RETRYABLE_ERROR_CODES.includes(error.code);\r\n      \r\n      if (!isRetryable || attempt === maxRetries) {\r\n        break;\r\n      }\r\n\r\n      console.warn(\r\n        `[Resilience] Falha na operação (tentativa ${attempt + 1}/${maxRetries + 1}). ` +\r\n        `Erro: ${error.code}. Tentando novamente em ${delay}ms...`\r\n      );\r\n\r\n      await new Promise((resolve) => setTimeout(resolve, delay));\r\n      delay = Math.min(delay * factor, maxDelay);\r\n    }\r\n  }\r\n\r\n  console.error('[Resilience] Operação falhou permanentemente após retries.', lastError);\r\n  throw lastError;\r\n}\r\n\r\n/**\r\n * Função utilitária para salvar métricas em lote (batching) com consistência eventual.\r\n * Útil para picos de carga onde não queremos sobrecarregar o Firestore com escritas individuais.\r\n */\r\nexport class PersistenceQueue {\r\n  private queue: Array<{ id: string; data: any; collection: string }> = [];\r\n  private timer: NodeJS.Timeout | null = null;\r\n  private readonly BATCH_DELAY = 2000; // 2 segundos de acumulação\r\n\r\n  constructor(private saveFn: (batch: any[]) => Promise<void>) {}\r\n\r\n  add(id: string, collection: string, data: any) {\r\n    this.queue.push({ id, collection, data });\r\n    \r\n    if (!this.timer) {\r\n      this.timer = setTimeout(() => this.flush(), this.BATCH_DELAY);\r\n    }\r\n  }\r\n\r\n  private async flush() {\r\n    if (this.queue.length === 0) return;\r\n\r\n    const currentBatch = [...this.queue];\r\n    this.queue = [];\r\n    this.timer = null;\r\n\r\n    try {\r\n      await withResilience(() => this.saveFn(currentBatch));\r\n    } catch (error) {\r\n      console.error('[PersistenceQueue] Erro ao processar lote de persistência:', error);\r\n      // Opcional: Re-adicionar à fila ou salvar em localStorage para retry posterior\r\n    }\r\n  }\r\n}\r\n","import {\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  setDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  addDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  Timestamp,\r\n  onSnapshot,\r\n  DocumentReference,\r\n  increment,\r\n} from 'firebase/firestore';\r\nimport { db } from './config';\r\nimport { withResilience } from './resilience';\r\nimport { encryptSensitiveFields } from '../utils/encryption';\r\nimport type {\r\n  User,\r\n  Tenant,\r\n  Funnel,\r\n  FunnelContext,\r\n  Proposal,\r\n  Decision,\r\n  Conversation,\r\n  Message,\r\n  LibraryTemplate,\r\n  Brand,\r\n  DashboardStats,\r\n  Integration,\r\n} from '@/types/database';\r\nimport type { CampaignContext } from '@/types/campaign';\r\n\r\n// ============================================\r\n// USERS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo documento de usuário no Firestore.\r\n * \r\n * @param userId - O UID do usuário vindo do Firebase Auth.\r\n * @param data - Dados básicos do usuário (nome, e-mail, etc.).\r\n * @returns O ID do usuário criado.\r\n */\r\nexport async function createUser(userId: string, data: Omit<User, 'id' | 'createdAt' | 'lastLogin' | 'credits' | 'usage'>) {\r\n  const userRef = doc(db, 'users', userId);\r\n  const now = Timestamp.now();\r\n  \r\n  await setDoc(userRef, {\r\n    ...data,\r\n    credits: 10, // MVP Default: 10 credits (US-16.1)\r\n    usage: 0,\r\n    createdAt: now,\r\n    lastLogin: now,\r\n  });\r\n  \r\n  return userId;\r\n}\r\n\r\n/**\r\n * Busca o saldo de créditos do usuário.\r\n * US-16.1\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns O saldo de créditos ou 0 se não encontrar.\r\n */\r\nexport async function getUserCredits(userId: string): Promise<number> {\r\n  const userRef = doc(db, 'users', userId);\r\n  const userSnap = await getDoc(userRef);\r\n  \r\n  if (!userSnap.exists()) return 0;\r\n  \r\n  const userData = userSnap.data();\r\n  return userData.credits ?? 0;\r\n}\r\n\r\n/**\r\n * Atualiza os créditos e o uso do usuário de forma atômica.\r\n * US-16.1\r\n * \r\n * @param userId - O ID do usuário.\r\n * @param amount - Quantidade a incrementar/decrementar (ex: -1).\r\n */\r\nexport async function updateUserUsage(userId: string, amount: number = -1) {\r\n  const userRef = doc(db, 'users', userId);\r\n  await updateDoc(userRef, {\r\n    credits: increment(amount),\r\n    usage: increment(Math.abs(amount)),\r\n  });\r\n}\r\n\r\n/**\r\n * Define uma quantidade específica de créditos para o usuário.\r\n * US-16.3 (Apenas para Dev Mode)\r\n * \r\n * @param userId - O ID do usuário.\r\n * @param amount - Quantidade de créditos.\r\n */\r\nexport async function setCredits(userId: string, amount: number) {\r\n  const userRef = doc(db, 'users', userId);\r\n  await updateDoc(userRef, {\r\n    credits: amount,\r\n  });\r\n}\r\n\r\n/**\r\n * Busca os dados de um usuário pelo ID.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Os dados do usuário ou null se não for encontrado.\r\n */\r\nexport async function getUser(userId: string): Promise<User | null> {\r\n  const userRef = doc(db, 'users', userId);\r\n  const userSnap = await getDoc(userRef);\r\n  \r\n  if (!userSnap.exists()) return null;\r\n  \r\n  return { id: userSnap.id, ...userSnap.data() } as User;\r\n}\r\n\r\n/**\r\n * Atualiza o timestamp de último login do usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n */\r\nexport async function updateUserLastLogin(userId: string) {\r\n  const userRef = doc(db, 'users', userId);\r\n  await updateDoc(userRef, { lastLogin: Timestamp.now() });\r\n}\r\n\r\n// ============================================\r\n// TENANTS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo tenant (organização/conta multi-tenant).\r\n * \r\n * @param data - Dados do tenant.\r\n * @returns O ID do tenant criado.\r\n */\r\nexport async function createTenant(data: Omit<Tenant, 'id' | 'createdAt' | 'updatedAt'>) {\r\n  const now = Timestamp.now();\r\n  const tenantRef = await addDoc(collection(db, 'tenants'), {\r\n    ...data,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n  \r\n  return tenantRef.id;\r\n}\r\n\r\n/**\r\n * Busca os dados de um tenant pelo ID.\r\n * \r\n * @param tenantId - O ID do tenant.\r\n * @returns Os dados do tenant ou null se não encontrado.\r\n */\r\nexport async function getTenant(tenantId: string): Promise<Tenant | null> {\r\n  const tenantRef = doc(db, 'tenants', tenantId);\r\n  const tenantSnap = await getDoc(tenantRef);\r\n  \r\n  if (!tenantSnap.exists()) return null;\r\n  \r\n  return { id: tenantSnap.id, ...tenantSnap.data() } as Tenant;\r\n}\r\n\r\n// ============================================\r\n// FUNNELS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo funil de vendas.\r\n * \r\n * @param data - Dados de criação do funil, incluindo contexto e vinculação de usuário/tenant/marca.\r\n * @returns O ID do funil criado.\r\n */\r\nexport async function createFunnel(data: {\r\n  userId: string;\r\n  tenantId?: string;\r\n  name: string;\r\n  description?: string;\r\n  context: FunnelContext;\r\n  brandId?: string;\r\n}): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const funnelRef = await addDoc(collection(db, 'funnels'), {\r\n    ...data,\r\n    status: 'draft',\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n  \r\n  return funnelRef.id;\r\n}\r\n\r\n/**\r\n * Busca um funil específico pelo ID.\r\n * \r\n * @param funnelId - O ID do funil.\r\n * @returns O objeto Funnel ou null se não encontrado.\r\n */\r\nexport async function getFunnel(funnelId: string): Promise<Funnel | null> {\r\n  const funnelRef = doc(db, 'funnels', funnelId);\r\n  const funnelSnap = await getDoc(funnelRef);\r\n  \r\n  if (!funnelSnap.exists()) return null;\r\n  \r\n  return { id: funnelSnap.id, ...funnelSnap.data() } as Funnel;\r\n}\r\n\r\n/**\r\n * Recupera todos os funis pertencentes a um usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Array de funis ordenados pela última atualização.\r\n */\r\nexport async function getUserFunnels(userId: string): Promise<Funnel[]> {\r\n  // ST-11.6: Simplified query to avoid composite index (INC-004)\r\n  const q = query(\r\n    collection(db, 'funnels'),\r\n    where('userId', '==', userId)\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Funnel));\r\n  \r\n  // Sort in memory\r\n  return data.sort((a, b) => {\r\n    const dateA = a.updatedAt?.seconds || 0;\r\n    const dateB = b.updatedAt?.seconds || 0;\r\n    return dateB - dateA;\r\n  });\r\n}\r\n\r\n/**\r\n * Atualiza os dados de um funil existente.\r\n * Implementa resiliência via retry (ST-11.23).\r\n * \r\n * @param funnelId - O ID do funil.\r\n * @param data - Objeto parcial com os dados a serem atualizados.\r\n */\r\nexport async function updateFunnel(funnelId: string, data: Partial<Funnel>) {\r\n  const funnelRef = doc(db, 'funnels', funnelId);\r\n  await withResilience(async () => {\r\n    await updateDoc(funnelRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Exclui um funil permanentemente.\r\n * \r\n * @param funnelId - O ID do funil.\r\n */\r\nexport async function deleteFunnel(funnelId: string) {\r\n  const funnelRef = doc(db, 'funnels', funnelId);\r\n  await deleteDoc(funnelRef);\r\n}\r\n\r\n// ============================================\r\n// PROPOSALS (subcollection)\r\n// ============================================\r\n\r\n/**\r\n * Cria uma nova proposta estratégica vinculada a um funil.\r\n * Propostas são armazenadas como uma subcoleção do funil.\r\n * \r\n * @param funnelId - O ID do funil pai.\r\n * @param data - Dados da proposta estratégica.\r\n * @returns O ID da proposta criada.\r\n */\r\nexport async function createProposal(\r\n  funnelId: string,\r\n  data: Omit<Proposal, 'id' | 'funnelId' | 'createdAt'>\r\n): Promise<string> {\r\n  const proposalRef = await addDoc(\r\n    collection(db, 'funnels', funnelId, 'proposals'),\r\n    {\r\n      ...data,\r\n      funnelId,\r\n      createdAt: Timestamp.now(),\r\n    }\r\n  );\r\n  \r\n  return proposalRef.id;\r\n}\r\n\r\n/**\r\n * Recupera todas as propostas estratégicas de um funil.\r\n * \r\n * @param funnelId - O ID do funil.\r\n * @returns Array de propostas ordenadas pela versão (decrescente).\r\n */\r\nexport async function getFunnelProposals(funnelId: string): Promise<Proposal[]> {\r\n  const q = query(\r\n    collection(db, 'funnels', funnelId, 'proposals'),\r\n    orderBy('version', 'desc')\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Proposal));\r\n}\r\n\r\n// ============================================\r\n// DECISIONS (subcollection)\r\n// ============================================\r\n\r\n/**\r\n * Registra uma decisão tomada pelo usuário sobre um funil (aprovação, morte, etc.).\r\n * \r\n * @param funnelId - O ID do funil relacionado.\r\n * @param data - Detalhes da decisão e justificativa.\r\n * @returns O ID do registro da decisão.\r\n */\r\nexport async function createDecision(\r\n  funnelId: string,\r\n  data: Omit<Decision, 'id' | 'funnelId' | 'createdAt'>\r\n): Promise<string> {\r\n  const decisionRef = await addDoc(\r\n    collection(db, 'funnels', funnelId, 'decisions'),\r\n    {\r\n      ...data,\r\n      funnelId,\r\n      createdAt: Timestamp.now(),\r\n    }\r\n  );\r\n  \r\n  return decisionRef.id;\r\n}\r\n\r\n// ============================================\r\n// CONVERSATIONS\r\n// ============================================\r\n\r\n/**\r\n * Inicia uma nova conversa no chat.\r\n * \r\n * @param data - Dados básicos da conversa (usuário, título, contexto, marca).\r\n * @returns O ID da conversa criada.\r\n */\r\nexport async function createConversation(data: {\r\n  userId: string;\r\n  tenantId?: string;\r\n  title: string;\r\n  context?: Conversation['context'];\r\n  brandId?: string;\r\n}): Promise<string> {\r\n  const now = Timestamp.now();\r\n  \r\n  // US-20.2: Remover campos undefined para evitar erro do Firestore\r\n  const cleanData = Object.fromEntries(\r\n    Object.entries(data).filter(([_, v]) => v !== undefined)\r\n  );\r\n\r\n  const convRef = await addDoc(collection(db, 'conversations'), {\r\n    ...cleanData,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n  \r\n  return convRef.id;\r\n}\r\n\r\n/**\r\n * Busca uma conversa específica pelo ID.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @returns O objeto Conversation ou null se não encontrada.\r\n */\r\nexport async function getConversation(conversationId: string): Promise<Conversation | null> {\r\n  const convRef = doc(db, 'conversations', conversationId);\r\n  const convSnap = await getDoc(convRef);\r\n  \r\n  if (!convSnap.exists()) return null;\r\n  \r\n  return { id: convSnap.id, ...convSnap.data() } as Conversation;\r\n}\r\n\r\n/**\r\n * Recupera as conversas recentes de um usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Array das últimas 50 conversas.\r\n */\r\nexport async function getUserConversations(userId: string): Promise<Conversation[]> {\r\n  // ST-11.6: Simplified query to avoid composite index (INC-004)\r\n  const q = query(\r\n    collection(db, 'conversations'),\r\n    where('userId', '==', userId),\r\n    limit(50)\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Conversation));\r\n  \r\n  // Sort in memory\r\n  return data.sort((a, b) => {\r\n    const dateA = a.updatedAt?.seconds || 0;\r\n    const dateB = b.updatedAt?.seconds || 0;\r\n    return dateB - dateA;\r\n  });\r\n}\r\n\r\n/**\r\n * Atualiza metadados de uma conversa (ex: título).\r\n * Implementa resiliência via retry (ST-11.23).\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @param data - Campos parciais a atualizar.\r\n */\r\nexport async function updateConversation(conversationId: string, data: Partial<Conversation>) {\r\n  const convRef = doc(db, 'conversations', conversationId);\r\n  await withResilience(async () => {\r\n    await updateDoc(convRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Exclui uma conversa permanentemente.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n */\r\nexport async function deleteConversation(conversationId: string) {\r\n  const convRef = doc(db, 'conversations', conversationId);\r\n  await deleteDoc(convRef);\r\n}\r\n\r\n// ============================================\r\n// MESSAGES (subcollection)\r\n// ============================================\r\n\r\n/**\r\n * Adiciona uma mensagem a uma conversa.\r\n * Também atualiza o timestamp de atualização da conversa pai.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @param data - Conteúdo da mensagem e remetente.\r\n * @returns O ID da mensagem criada.\r\n */\r\nexport async function addMessage(\r\n  conversationId: string,\r\n  data: Omit<Message, 'id' | 'conversationId' | 'createdAt'>\r\n): Promise<string> {\r\n  const messageRef = await addDoc(\r\n    collection(db, 'conversations', conversationId, 'messages'),\r\n    {\r\n      ...data,\r\n      conversationId,\r\n      createdAt: Timestamp.now(),\r\n    }\r\n  );\r\n  \r\n  // Update conversation's updatedAt\r\n  await updateConversation(conversationId, {});\r\n  \r\n  return messageRef.id;\r\n}\r\n\r\n/**\r\n * Recupera todas as mensagens de uma conversa.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @returns Array de mensagens ordenadas cronologicamente.\r\n */\r\nexport async function getConversationMessages(conversationId: string): Promise<Message[]> {\r\n  const q = query(\r\n    collection(db, 'conversations', conversationId, 'messages'),\r\n    orderBy('createdAt', 'asc')\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message));\r\n}\r\n\r\n/**\r\n * Cria uma inscrição (listener) para receber atualizações de mensagens em tempo real.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @param callback - Função executada a cada atualização da lista de mensagens.\r\n * @returns Função para cancelar a inscrição.\r\n */\r\nexport function subscribeToMessages(\r\n  conversationId: string,\r\n  callback: (messages: Message[]) => void\r\n) {\r\n  const q = query(\r\n    collection(db, 'conversations', conversationId, 'messages'),\r\n    orderBy('createdAt', 'asc')\r\n  );\r\n  \r\n  return onSnapshot(q, (snapshot) => {\r\n    const messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message));\r\n    callback(messages);\r\n  });\r\n}\r\n\r\n// ============================================\r\n// LIBRARY TEMPLATES\r\n// ============================================\r\n\r\n/**\r\n * Busca modelos da biblioteca com filtros opcionais.\r\n * \r\n * @param filters - Filtros por tipo de funil ou vertical de negócio.\r\n * @returns Array de modelos de biblioteca ordenados por popularidade.\r\n */\r\nexport async function getLibraryTemplates(\r\n  filters?: { type?: string; vertical?: string }\r\n): Promise<LibraryTemplate[]> {\r\n  let q = query(collection(db, 'library'), orderBy('usageCount', 'desc'));\r\n  \r\n  const snapshot = await getDocs(q);\r\n  let templates = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as LibraryTemplate));\r\n  \r\n  // Client-side filtering (Firestore doesn't support multiple inequality filters)\r\n  if (filters?.type) {\r\n    templates = templates.filter(t => t.type === filters.type);\r\n  }\r\n  \r\n  return templates;\r\n}\r\n\r\n/**\r\n * Salva um novo modelo na biblioteca pública ou privada.\r\n * \r\n * @param data - Dados do modelo (estrutura, descrição, tipo).\r\n * @returns O ID do modelo criado.\r\n */\r\nexport async function saveToLibrary(data: Omit<LibraryTemplate, 'id' | 'createdAt' | 'usageCount'>) {\r\n  const templateRef = await addDoc(collection(db, 'library'), {\r\n    ...data,\r\n    usageCount: 0,\r\n    createdAt: Timestamp.now(),\r\n  });\r\n  \r\n  return templateRef.id;\r\n}\r\n\r\n// ============================================\r\n// STATS (for dashboard)\r\n// ============================================\r\n\r\n/**\r\n * Consolida estatísticas de uso para o painel de controle do usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Objeto com contagens de funis ativos, avaliações pendentes e decisões do mês.\r\n */\r\nexport async function getUserStats(userId: string): Promise<DashboardStats> {\r\n  const [funnels, conversations] = await Promise.all([\r\n    getUserFunnels(userId),\r\n    getUserConversations(userId),\r\n  ]);\r\n  \r\n  const activeFunnels = funnels.filter(f => \r\n    !['completed', 'killed'].includes(f.status)\r\n  ).length;\r\n  \r\n  const pendingEvaluations = funnels.filter(f => \r\n    f.status === 'review'\r\n  ).length;\r\n  \r\n  const decisionsThisMonth = funnels.filter(f => {\r\n    const createdAt = f.createdAt.toDate();\r\n    const now = new Date();\r\n    return (\r\n      createdAt.getMonth() === now.getMonth() &&\r\n      createdAt.getFullYear() === now.getFullYear() &&\r\n      ['approved', 'killed', 'adjusting'].includes(f.status)\r\n    );\r\n  }).length;\r\n  \r\n  // US-1.5.3: Benchmarks devem ser carregados via API ou Server Action para evitar vazamento de 'fs' para o cliente.\r\n  const performance_benchmarks = [\r\n    { metric: 'CPC Médio', value: '--', benchmark_2026: 'R$ 0,50', status: 'neutral' as const },\r\n    { metric: 'CTR Global', value: '--', benchmark_2026: '2.5%', status: 'neutral' as const },\r\n    { metric: 'ROAS Alvo', value: '--', benchmark_2026: '4.0x', status: 'neutral' as const }\r\n  ];\r\n\r\n  return {\r\n    activeFunnels,\r\n    pendingEvaluations,\r\n    decisionsThisMonth,\r\n    totalConversations: conversations.length,\r\n    performance_benchmarks,\r\n  };\r\n}\r\n\r\n\r\n// ============================================\r\n// BRANDS\r\n// ============================================\r\n\r\n/**\r\n * Busca uma marca específica pelo ID.\r\n */\r\nexport async function getBrand(brandId: string): Promise<Brand | null> {\r\n  const brandRef = doc(db, 'brands', brandId);\r\n  const brandSnap = await getDoc(brandRef);\r\n  \r\n  if (!brandSnap.exists()) return null;\r\n  \r\n  return { id: brandSnap.id, ...brandSnap.data() } as Brand;\r\n}\r\n\r\n/**\r\n * Atualiza os dados de uma marca.\r\n */\r\nexport async function updateBrand(brandId: string, data: Partial<Brand>) {\r\n  const brandRef = doc(db, 'brands', brandId);\r\n  await updateDoc(brandRef, {\r\n    ...data,\r\n    updatedAt: Timestamp.now(),\r\n  });\r\n}\r\n\r\n// ============================================\r\n// INTEGRATIONS\r\n// ============================================\r\n\r\n/**\r\n * Salva ou atualiza uma integração para um tenant.\r\n * \r\n * @param tenantId - O ID do tenant.\r\n * @param provider - O provedor da integração (ex: 'meta').\r\n * @param data - Configurações da integração.\r\n */\r\nexport async function saveIntegration(\r\n  tenantId: string,\r\n  provider: Integration['provider'],\r\n  data: any\r\n) {\r\n  const integrationId = provider; // Usamos o provider como ID fixo por enquanto (um por tipo)\r\n  const integrationRef = doc(db, 'tenants', tenantId, 'integrations', integrationId);\r\n  const now = Timestamp.now();\r\n\r\n  // ST-18.6: Criptografia de tokens sensíveis antes de salvar no Firestore\r\n  const secureConfig = encryptSensitiveFields(data);\r\n\r\n  const integrationData = {\r\n    id: integrationId,\r\n    tenantId,\r\n    provider,\r\n    status: 'active' as const,\r\n    config: secureConfig,\r\n    updatedAt: now,\r\n  };\r\n\r\n  // Tenta buscar se já existe para manter o createdAt\r\n  const snap = await getDoc(integrationRef);\r\n  if (snap.exists()) {\r\n    await updateDoc(integrationRef, integrationData);\r\n  } else {\r\n    await setDoc(integrationRef, {\r\n      ...integrationData,\r\n      createdAt: now,\r\n    });\r\n  }\r\n\r\n  return integrationId;\r\n}\r\n\r\n/**\r\n * Busca todas as integrações de um tenant.\r\n * \r\n * @param tenantId - O ID do tenant.\r\n */\r\nexport async function getIntegrations(tenantId: string): Promise<Integration[]> {\r\n  const q = query(collection(db, 'tenants', tenantId, 'integrations'));\r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Integration));\r\n}\r\n\r\n// ============================================\r\n// CAMPAIGNS (Manifesto / Golden Thread)\r\n// ============================================\r\n\r\n/**\r\n * Cria uma nova campanha (Manifesto da Linha de Ouro) a partir de um funil aprovado.\r\n * Segue o contrato da ST-11.21: CampaignId != FunnelId.\r\n */\r\nexport async function createCampaign(data: {\r\n  funnelId: string;\r\n  userId: string;\r\n  brandId: string;\r\n  name: string;\r\n  funnelData: CampaignContext['funnel'];\r\n}): Promise<string> {\r\n  const timestamp = Date.now();\r\n  const shortId = Math.random().toString(36).substring(2, 7);\r\n  const campaignId = `${data.funnelId}_${timestamp}_${shortId}`;\r\n  \r\n  const now = Timestamp.now();\r\n  const campaignRef = doc(db, 'campaigns', campaignId);\r\n  \r\n  const campaignData: CampaignContext = {\r\n    id: campaignId,\r\n    funnelId: data.funnelId,\r\n    userId: data.userId,\r\n    brandId: data.brandId,\r\n    name: data.name,\r\n    status: 'planning',\r\n    funnel: data.funnelData,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n  \r\n  await setDoc(campaignRef, campaignData);\r\n  return campaignId;\r\n}\r\n\r\n/**\r\n * Busca uma campanha pelo ID.\r\n */\r\nexport async function getCampaign(campaignId: string): Promise<CampaignContext | null> {\r\n  const campaignRef = doc(db, 'campaigns', campaignId);\r\n  const campaignSnap = await getDoc(campaignRef);\r\n  \r\n  if (!campaignSnap.exists()) return null;\r\n  \r\n  return { id: campaignSnap.id, ...campaignSnap.data() } as CampaignContext;\r\n}\r\n\r\n/**\r\n * Atualiza o manifesto de uma campanha de forma atômica (Upsert).\r\n * Implementa resiliência via retry e backoff (ST-11.23).\r\n */\r\nexport async function updateCampaignManifesto(\r\n  campaignId: string, \r\n  data: Partial<CampaignContext>\r\n) {\r\n  const campaignRef = doc(db, 'campaigns', campaignId);\r\n  \r\n  return await withResilience(async () => {\r\n    await setDoc(campaignRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    }, { merge: true });\r\n  });\r\n}\r\n\r\n\r\n","'use client';\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport { useAuthStore } from '@/lib/stores/auth-store';\r\nimport { getUser, createUser, updateUserLastLogin } from '@/lib/firebase/firestore';\r\nimport type { User } from '@/types/database';\r\n\r\nexport function useUser() {\r\n  const { user: authUser, isLoading: authLoading } = useAuthStore();\r\n  const [user, setUser] = useState<User | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    async function loadUser() {\r\n      if (authLoading) return;\r\n      \r\n      if (!authUser) {\r\n        setUser(null);\r\n        setIsLoading(false);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        // Try to get existing user\r\n        let userData = await getUser(authUser.uid);\r\n\r\n        // If user doesn't exist in Firestore, create it\r\n        if (!userData) {\r\n          const newUserData: any = {\r\n            email: authUser.email || '',\r\n            name: authUser.displayName || authUser.email?.split('@')[0] || 'Usuário',\r\n            role: 'admin', // First user is admin\r\n          };\r\n          \r\n          // Só adiciona avatar se existir\r\n          if (authUser.photoURL) {\r\n            newUserData.avatar = authUser.photoURL;\r\n          }\r\n          \r\n          await createUser(authUser.uid, newUserData);\r\n          userData = await getUser(authUser.uid);\r\n        } else {\r\n          // Update last login\r\n          await updateUserLastLogin(authUser.uid);\r\n        }\r\n\r\n        setUser(userData);\r\n        setError(null);\r\n      } catch (err) {\r\n        console.error('Error loading user:', err);\r\n        setError('Erro ao carregar usuário');\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    }\r\n\r\n    loadUser();\r\n  }, [authUser, authLoading]);\r\n\r\n  return { user, isLoading: isLoading || authLoading, error };\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"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","ignoreList":[0]}
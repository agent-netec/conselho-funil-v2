{"version":3,"sources":["../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/config.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/resilience.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/ai/embeddings.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/ai/pinecone.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/uuid/dist-node/native.js","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/uuid/dist-node/rng.js","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/uuid/dist-node/regex.js","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/uuid/dist-node/validate.js","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/uuid/dist-node/stringify.js","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/node_modules/uuid/dist-node/v4.js","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/intelligence.ts"],"sourcesContent":["// US-28.01: Mocks robustos para evitar crashes durante o build estático da Next.js\r\nconst mockInternal = {\r\n  container: {\r\n    get: () => ({}),\r\n  }\r\n};\r\n\r\nconst mockService = {\r\n  currentUser: null,\r\n  onAuthStateChanged: () => () => {},\r\n  signOut: async () => {},\r\n  getApp: () => ({ container: mockInternal.container }),\r\n  app: { container: mockInternal.container },\r\n  INTERNAL: mockInternal,\r\n  container: mockInternal.container,\r\n  collection: () => ({ doc: () => ({ get: async () => ({ exists: () => false }) }) }),\r\n  doc: () => ({ get: async () => ({ exists: () => false }) }),\r\n  ref: () => ({ put: async () => ({}) }),\r\n};\r\n\r\n// Global mocks for Firebase SDK internal access\r\nif (typeof global !== 'undefined') {\r\n  (global as any).firebase = (global as any).firebase || { INTERNAL: mockInternal };\r\n  (global as any).firebaseApp = (global as any).firebaseApp || mockService;\r\n  (global as any)._firebaseApp = (global as any)._firebaseApp || mockService;\r\n  (global as any).firebaseInternalContainer = mockInternal.container;\r\n}\r\n\r\n// US-28.01: Detect build phase more reliably\r\nconst isBuild = typeof window === 'undefined' && \r\n  (process.env.NEXT_PHASE === 'phase-production-build' || process.env.NODE_ENV === 'production');\r\n\r\nlet appInstance: any = null;\r\nlet authInstance: any = null;\r\nlet dbInstance: any = null;\r\nlet storageInstance: any = null;\r\n\r\nfunction initialize() {\r\n  if (isBuild) return;\r\n  if (appInstance) return;\r\n\r\n  try {\r\n    const { initializeApp, getApps } = require('firebase/app');\r\n    const { getAuth } = require('firebase/auth');\r\n    const { initializeFirestore, CACHE_SIZE_UNLIMITED } = require('firebase/firestore');\r\n    const { getStorage } = require('firebase/storage');\r\n\r\n    const apiKey = (process.env.NEXT_PUBLIC_FIREBASE_API_KEY ?? '').trim();\r\n    const firebaseConfig = {\r\n      apiKey,\r\n      authDomain: (process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN ?? '').trim(),\r\n      projectId: (process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID ?? '').trim(),\r\n      storageBucket: (process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET ?? '').trim(),\r\n      messagingSenderId: (process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID ?? '').trim(),\r\n      appId: (process.env.NEXT_PUBLIC_FIREBASE_APP_ID ?? '').trim(),\r\n    };\r\n\r\n    if (apiKey) {\r\n      appInstance = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];\r\n      if (appInstance && process.env.SKIP_AUTH !== '1') {\r\n        authInstance = getAuth(appInstance);\r\n        dbInstance = initializeFirestore(appInstance, {\r\n          experimentalForceLongPolling: true,\r\n          cacheSizeBytes: CACHE_SIZE_UNLIMITED,\r\n        });\r\n        storageInstance = getStorage(appInstance);\r\n      }\r\n    }\r\n  } catch (e) {\r\n    // Silently fail during build\r\n  }\r\n}\r\n\r\n// Export as getters to ensure they are not evaluated too early and can be mocked\r\nexport const auth = isBuild ? mockService : (initialize(), authInstance || mockService);\r\nexport const db = isBuild ? mockService : (initialize(), dbInstance || mockService);\r\nexport const storage = isBuild ? mockService : (initialize(), storageInstance || mockService);\r\nexport default isBuild ? null : (initialize(), appInstance);\r\n","import { \r\n  FirestoreError,\r\n} from 'firebase/firestore';\r\n\r\n/**\r\n * Opções para a estratégia de resiliência.\r\n */\r\ninterface ResilienceOptions {\r\n  maxRetries?: number;\r\n  initialDelay?: number;\r\n  maxDelay?: number;\r\n  factor?: number;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Required<ResilienceOptions> = {\r\n  maxRetries: 3,\r\n  initialDelay: 1000,\r\n  maxDelay: 10000,\r\n  factor: 2,\r\n};\r\n\r\n/**\r\n * Erros do Firestore que são considerados transientes e seguros para tentar novamente.\r\n * Ref: https://firebase.google.com/docs/firestore/manage-data/error-handling\r\n */\r\nconst RETRYABLE_ERROR_CODES = [\r\n  'aborted',\r\n  'deadline-exceeded',\r\n  'resource-exhausted',\r\n  'unavailable',\r\n  'internal',\r\n];\r\n\r\n/**\r\n * Executa uma operação do Firestore com estratégia de retry e exponential backoff.\r\n * \r\n * @param operation - A função assíncrona que executa a operação do Firestore.\r\n * @param options - Configurações de retry.\r\n * @returns O resultado da operação.\r\n */\r\nexport async function withResilience<T>(\r\n  operation: () => Promise<T>,\r\n  options: ResilienceOptions = {}\r\n): Promise<T> {\r\n  const { maxRetries, initialDelay, maxDelay, factor } = {\r\n    ...DEFAULT_OPTIONS,\r\n    ...options,\r\n  };\r\n\r\n  let lastError: any;\r\n  let delay = initialDelay;\r\n\r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await operation();\r\n    } catch (error: any) {\r\n      lastError = error;\r\n\r\n      // Verifica se o erro é transiente\r\n      const isRetryable = error instanceof FirestoreError && RETRYABLE_ERROR_CODES.includes(error.code);\r\n      \r\n      if (!isRetryable || attempt === maxRetries) {\r\n        break;\r\n      }\r\n\r\n      console.warn(\r\n        `[Resilience] Falha na operação (tentativa ${attempt + 1}/${maxRetries + 1}). ` +\r\n        `Erro: ${error.code}. Tentando novamente em ${delay}ms...`\r\n      );\r\n\r\n      await new Promise((resolve) => setTimeout(resolve, delay));\r\n      delay = Math.min(delay * factor, maxDelay);\r\n    }\r\n  }\r\n\r\n  console.error('[Resilience] Operação falhou permanentemente após retries.', lastError);\r\n  throw lastError;\r\n}\r\n\r\n/**\r\n * Função utilitária para salvar métricas em lote (batching) com consistência eventual.\r\n * Útil para picos de carga onde não queremos sobrecarregar o Firestore com escritas individuais.\r\n */\r\nexport class PersistenceQueue {\r\n  private queue: Array<{ id: string; data: any; collection: string }> = [];\r\n  private timer: NodeJS.Timeout | null = null;\r\n  private readonly BATCH_DELAY = 2000; // 2 segundos de acumulação\r\n\r\n  constructor(private saveFn: (batch: any[]) => Promise<void>) {}\r\n\r\n  add(id: string, collection: string, data: any) {\r\n    this.queue.push({ id, collection, data });\r\n    \r\n    if (!this.timer) {\r\n      this.timer = setTimeout(() => this.flush(), this.BATCH_DELAY);\r\n    }\r\n  }\r\n\r\n  private async flush() {\r\n    if (this.queue.length === 0) return;\r\n\r\n    const currentBatch = [...this.queue];\r\n    this.queue = [];\r\n    this.timer = null;\r\n\r\n    try {\r\n      await withResilience(() => this.saveFn(currentBatch));\r\n    } catch (error) {\r\n      console.error('[PersistenceQueue] Erro ao processar lote de persistência:', error);\r\n      // Opcional: Re-adicionar à fila ou salvar em localStorage para retry posterior\r\n    }\r\n  }\r\n}\r\n","import { GoogleGenerativeAI } from '@google/generative-ai';\r\nimport { \r\n  doc, \r\n  getDoc, \r\n  setDoc, \r\n  Timestamp \r\n} from 'firebase/firestore';\r\nimport { db } from '../firebase/config';\r\n\r\n/**\r\n * Get Gemini API Key - reads from environment variable at runtime\r\n */\r\nfunction getGeminiApiKey(): string | undefined {\r\n  // Acesso direto para garantir que o Next.js/Turbopack faça a injeção no cliente\r\n  const public_key = (process.env.NEXT_PUBLIC_GOOGLE_AI_API_KEY ?? '').trim();\r\n  const private_key = (process.env.GOOGLE_AI_API_KEY ?? '').trim();\r\n  \r\n  const key = public_key || private_key;\r\n  \r\n  if (!key && typeof window !== 'undefined') {\r\n    console.error('❌ [Embeddings] NEXT_PUBLIC_GOOGLE_AI_API_KEY não encontrada no bundle do navegador. Verifique se o servidor foi reiniciado após editar o .env.local.');\r\n  }\r\n  \r\n  return key;\r\n}\r\n\r\n/**\r\n * Simple hashing function for cache keys\r\n */\r\nasync function getCacheKey(text: string): Promise<string> {\r\n  const msgUint8 = new TextEncoder().encode(text.trim().toLowerCase());\r\n  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\r\n}\r\n\r\n/**\r\n * Generates an embedding for a given text using Gemini's text-embedding-004 model.\r\n * Includes a Firestore cache to reduce costs and latency.\r\n * \r\n * @param text - The input text to embed.\r\n * @returns A promise that resolves to an array of numbers (768 dimensions).\r\n * @throws Error if the API key is missing or the request fails.\r\n */\r\nexport async function generateEmbedding(text: string): Promise<number[]> {\r\n  // Se preferir evitar o SDK (que vem falhando com API_KEY_INVALID), usamos o endpoint direto.\r\n  const apiKey = getGeminiApiKey();\r\n  if (!apiKey) {\r\n    throw new Error('GOOGLE_AI_API_KEY not configured for embeddings');\r\n  }\r\n\r\n  const startTime = Date.now();\r\n  const cacheKey = await getCacheKey(text);\r\n  \r\n  // 1. Check Cache (Firestore)\r\n  try {\r\n    const cacheRef = doc(db, 'query_cache', cacheKey);\r\n    const cacheSnap = await getDoc(cacheRef);\r\n    \r\n    if (cacheSnap.exists()) {\r\n      const data = cacheSnap.data();\r\n      const ttl = 30 * 24 * 60 * 60 * 1000; // 30 days\r\n      const isExpired = (Timestamp.now().toMillis() - data.createdAt.toMillis()) > ttl;\r\n      \r\n      if (!isExpired) {\r\n        console.log(`[Embeddings] Cache HIT for key: ${cacheKey.substring(0, 8)} (${Date.now() - startTime}ms)`);\r\n        return data.embedding;\r\n      }\r\n    }\r\n  } catch (cacheError) {\r\n    console.warn('[Embeddings] Cache read error:', cacheError);\r\n  }\r\n\r\n  // 2. Cache MISS - Call API\r\n  try {\r\n    // RESOLUÇÃO DEFINITIVA (Dandara/Kai): \r\n    // 1. text-embedding-004 e embedding-001 via SDK (@google/generative-ai) estão retornando API_KEY_INVALID \r\n    //    mesmo com chaves válidas, possivelmente por depreciação ou conflito de headers do SDK.\r\n    // 2. A chamada direta via fetch para 'gemini-embedding-001' ignorando o SDK funciona 100%.\r\n    // 3. Mantemos o fetch direto como padrão para garantir estabilidade do RAG.\r\n    \r\n    console.log(`[Embeddings] Calling text-embedding-004 with dimensionality: 768`);\r\n    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'x-goog-api-key': apiKey,\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'models/text-embedding-004',\r\n        content: { parts: [{ text }] },\r\n        outputDimensionality: 768,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errTxt = await response.text();\r\n      throw new Error(`Embedding API failed: ${response.status} ${errTxt}`);\r\n    }\r\n\r\n    const result = await response.json();\r\n    const embedding = result?.embedding?.values;\r\n    if (!Array.isArray(embedding)) {\r\n      throw new Error('Embedding API returned no values');\r\n    }\r\n    \r\n    // 3. Save to Cache (Async)\r\n    const cacheRef = doc(db, 'query_cache', cacheKey);\r\n    setDoc(cacheRef, {\r\n      query: text.substring(0, 500), // Store snippet for debugging\r\n      embedding,\r\n      createdAt: Timestamp.now(),\r\n    }).catch(err => console.error('[Embeddings] Cache write error:', err));\r\n\r\n    console.log(`[Embeddings] Cache MISS - API called (${Date.now() - startTime}ms)`);\r\n    return embedding;\r\n  } catch (error) {\r\n    console.error('[Embeddings] Error generating embedding:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Generates embeddings for a batch of texts.\r\n * Handles partial cache hits to minimize API usage.\r\n * Includes TTL check (30 days).\r\n * \r\n * @param texts - Array of strings to embed.\r\n * @returns A promise that resolves to an array of number arrays.\r\n */\r\nexport async function generateEmbeddingsBatch(texts: string[]): Promise<number[][]> {\r\n  const startTime = Date.now();\r\n  const results: (number[] | null)[] = new Array(texts.length).fill(null);\r\n  const missIndices: number[] = [];\r\n  const missTexts: string[] = [];\r\n  const ttl = 30 * 24 * 60 * 60 * 1000; // 30 days\r\n  const nowMillis = Timestamp.now().toMillis();\r\n\r\n  // 1. Check Cache for each text\r\n  for (let i = 0; i < texts.length; i++) {\r\n    const text = texts[i];\r\n    const cacheKey = await getCacheKey(text);\r\n    \r\n    try {\r\n      const cacheRef = doc(db, 'query_cache', cacheKey);\r\n      const cacheSnap = await getDoc(cacheRef);\r\n      \r\n      if (cacheSnap.exists()) {\r\n        const data = cacheSnap.data();\r\n        const isExpired = (nowMillis - data.createdAt.toMillis()) > ttl;\r\n        \r\n        if (!isExpired) {\r\n          results[i] = data.embedding;\r\n          continue;\r\n        }\r\n      }\r\n    } catch (err) {\r\n      // Ignore cache errors and treat as miss\r\n    }\r\n    \r\n    missIndices.push(i);\r\n    missTexts.push(text);\r\n  }\r\n\r\n  if (missTexts.length === 0) {\r\n    console.log(`[Embeddings] Batch Cache HIT (100%) - ${texts.length} items (${Date.now() - startTime}ms)`);\r\n    return results as number[][];\r\n  }\r\n\r\n  // 2. Call API for MISSES\r\n  const apiKey = getGeminiApiKey();\r\n  if (!apiKey) {\r\n    throw new Error('GOOGLE_AI_API_KEY not configured for embeddings');\r\n  }\r\n\r\n  const genAI = new GoogleGenerativeAI(apiKey);\r\n  const model = genAI.getGenerativeModel({ model: \"text-embedding-004\" });\r\n\r\n  try {\r\n    console.log(`[Embeddings] Batch Cache MISS - Calling API for ${missTexts.length}/${texts.length} items`);\r\n    \r\n    // Process in chunks of 90 (Google AI API limit is 100, we use 90 to be safe and avoid overhead issues)\r\n    // ST-11.23 Hotfix: Avoid \"at most 100 requests\" error\r\n    const BATCH_SIZE = 90;\r\n    const newEmbeddings: number[][] = [];\r\n    \r\n    for (let i = 0; i < missTexts.length; i += BATCH_SIZE) {\r\n      const batchTexts = missTexts.slice(i, i + BATCH_SIZE);\r\n      console.log(`[Embeddings] Processing API sub-batch ${i / BATCH_SIZE + 1} (${batchTexts.length} items)`);\r\n      \r\n      // Switching to fetch to avoid SDK inconsistencies (Ref: generateEmbedding)\r\n      const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:batchEmbedContents', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'x-goog-api-key': apiKey,\r\n        },\r\n        body: JSON.stringify({\r\n          requests: batchTexts.map((text) => ({\r\n            model: 'models/text-embedding-004',\r\n            content: { parts: [{ text }] },\r\n            outputDimensionality: 768\r\n          })),\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errTxt = await response.text();\r\n        throw new Error(`Batch Embedding API failed: ${response.status} ${errTxt}`);\r\n      }\r\n\r\n      const batchResult = await response.json();\r\n      \r\n      if (!batchResult.embeddings || !Array.isArray(batchResult.embeddings)) {\r\n        throw new Error('Batch Embedding API returned invalid format');\r\n      }\r\n\r\n      newEmbeddings.push(...batchResult.embeddings.map((e: any) => e.values));\r\n    }\r\n    \r\n    // 3. Save new embeddings to Cache and update results\r\n    for (let i = 0; i < missIndices.length; i++) {\r\n      const originalIdx = missIndices[i];\r\n      const embedding = newEmbeddings[i];\r\n      const text = missTexts[i];\r\n      results[originalIdx] = embedding;\r\n      \r\n      const cacheKey = await getCacheKey(text);\r\n      const cacheRef = doc(db, 'query_cache', cacheKey);\r\n      setDoc(cacheRef, {\r\n        query: text.substring(0, 500),\r\n        embedding,\r\n        createdAt: Timestamp.now(),\r\n      }).catch(err => console.error('[Embeddings] Cache write error:', err));\r\n    }\r\n\r\n    console.log(`[Embeddings] Batch completed (${Date.now() - startTime}ms)`);\r\n    return results as number[][];\r\n  } catch (error) {\r\n    console.error('[Embeddings] Error generating batch embeddings:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n","import { type PineconeRecord, type Index } from '@pinecone-database/pinecone';\r\n\r\nconst EXPECTED_DIMENSION = 768; // text-embedding-004\r\n\r\n/**\r\n * Pinecone SDK v6 não aceita mais a propriedade `environment`.\r\n */\r\nfunction getEnv() {\r\n  const apiKey = process.env.PINECONE_API_KEY;\r\n  const indexName = process.env.PINECONE_INDEX || process.env.PINECONE_INDEX_NAME || 'cf-dev-assets';\r\n  const host = process.env.PINECONE_HOST || process.env.PINECONE_HOST_URL;\r\n\r\n  if (!apiKey && typeof window === 'undefined') {\r\n    throw new Error('PINECONE_API_KEY ausente.');\r\n  }\r\n  return { apiKey, indexName, host };\r\n}\r\n\r\nlet cachedClient: any = null;\r\nlet cachedIndex: Index | null = null;\r\n\r\nexport async function getPineconeClient() {\r\n  if (typeof window !== 'undefined') return null;\r\n  if (cachedClient) return cachedClient;\r\n\r\n  const { apiKey } = getEnv();\r\n  const { Pinecone } = await import('@pinecone-database/pinecone');\r\n  cachedClient = new Pinecone({ apiKey: apiKey! });\r\n  return cachedClient;\r\n}\r\n\r\nexport async function getPineconeIndex(): Promise<Index | null> {\r\n  if (typeof window !== 'undefined') return null;\r\n  if (cachedIndex) return cachedIndex;\r\n\r\n  const { indexName, host } = getEnv();\r\n  const client = await getPineconeClient();\r\n  if (!client) return null;\r\n  \r\n  cachedIndex = host ? client.index(indexName, host) : client.index(indexName);\r\n  return cachedIndex;\r\n}\r\n\r\nexport async function upsertToPinecone(\r\n  records: PineconeRecord[],\r\n  options: { namespace?: string } = {}\r\n) {\r\n  if (typeof window !== 'undefined' || !records?.length) return { upserted: 0 };\r\n\r\n  const index = await getPineconeIndex();\r\n  if (!index) return { upserted: 0 };\r\n\r\n  const target = options.namespace ? index.namespace(options.namespace) : index;\r\n  await target.upsert(records);\r\n  return { upserted: records.length };\r\n}\r\n\r\nexport async function queryPinecone(params: {\r\n  vector: number[];\r\n  topK?: number;\r\n  namespace?: string;\r\n  filter?: Record<string, unknown>;\r\n}) {\r\n  if (typeof window !== 'undefined') return { matches: [] };\r\n  \r\n  const { vector, topK = 10, namespace, filter } = params;\r\n  const index = await getPineconeIndex();\r\n  if (!index) return { matches: [] };\r\n\r\n  const target = namespace ? index.namespace(namespace) : index;\r\n  return await target.query({\r\n    vector,\r\n    topK,\r\n    filter,\r\n    includeMetadata: true,\r\n  });\r\n}\r\n\r\nexport async function checkPineconeHealth() {\r\n  if (typeof window !== 'undefined') return null;\r\n  const { indexName } = getEnv();\r\n  const index = await getPineconeIndex();\r\n  const client = await getPineconeClient();\r\n  \r\n  if (!index || !client) return null;\r\n\r\n  const stats = await index.describeIndexStats();\r\n  const description = await client.describeIndex(indexName);\r\n\r\n  return {\r\n    status: 'connected',\r\n    index: indexName,\r\n    totalVectors: stats.totalRecordCount ?? 0,\r\n  };\r\n}\r\n","import { randomUUID } from 'node:crypto';\nexport default { randomUUID };\n","import { randomFillSync } from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n","import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","import {\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  addDoc,\r\n  updateDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  Timestamp,\r\n  setDoc,\r\n} from 'firebase/firestore';\r\nimport { db } from './config';\r\nimport { withResilience } from './resilience';\r\nimport type { \r\n  IntelligenceDocument, \r\n  BrandKeywordsConfig, \r\n  IntelligenceQueryFilter,\r\n  IntelligenceQueryResult,\r\n  CreateIntelligenceInput\r\n} from '@/types/intelligence';\r\nimport type { CompetitorProfile, IntelligenceAsset } from '@/types/competitors';\r\n\r\n// ============================================\r\n// COMPETITORS\r\n// ============================================\r\n\r\n/**\r\n * Busca um perfil de concorrente pelo ID.\r\n */\r\nexport async function getCompetitorProfile(brandId: string, competitorId: string): Promise<CompetitorProfile | null> {\r\n  const docRef = doc(db, 'brands', brandId, 'intelligence', 'competitors', competitorId);\r\n  const snap = await getDoc(docRef);\r\n  \r\n  if (!snap.exists()) return null;\r\n  \r\n  return { id: snap.id, ...snap.data() } as CompetitorProfile;\r\n}\r\n\r\n/**\r\n * Atualiza o perfil de um concorrente (ex: após Spy Scan).\r\n */\r\nexport async function updateCompetitorProfile(\r\n  brandId: string, \r\n  competitorId: string, \r\n  data: Partial<CompetitorProfile>\r\n) {\r\n  const docRef = doc(db, 'brands', brandId, 'intelligence', 'competitors', competitorId);\r\n  await withResilience(async () => {\r\n    await updateDoc(docRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    });\r\n  });\r\n}\r\n\r\n// ============================================\r\n// COMPETITOR ASSETS\r\n// ============================================\r\n\r\n/**\r\n * Salva um novo ativo de inteligência (screenshot, tech log, etc).\r\n * Collection: brands/{brandId}/intelligence/competitors/{competitorId}/assets\r\n */\r\nexport async function createIntelligenceAsset(\r\n  brandId: string,\r\n  competitorId: string,\r\n  asset: Omit<IntelligenceAsset, 'id'>\r\n): Promise<string> {\r\n  const assetsRef = collection(db, 'brands', brandId, 'intelligence', 'competitors', competitorId, 'assets');\r\n  const docRef = await addDoc(assetsRef, {\r\n    ...asset,\r\n    version: 1,\r\n  });\r\n  return docRef.id;\r\n}\r\n\r\n/**\r\n * Busca todos os ativos de um concorrente.\r\n */\r\nexport async function getCompetitorAssets(brandId: string, competitorId: string): Promise<IntelligenceAsset[]> {\r\n  const assetsRef = collection(db, 'brands', brandId, 'intelligence', 'competitors', competitorId, 'assets');\r\n  const q = query(assetsRef, orderBy('capturedAt', 'desc'));\r\n  const snap = await getDocs(q);\r\n  \r\n  return snap.docs.map(doc => ({ id: doc.id, ...doc.data() } as IntelligenceAsset));\r\n}\r\n\r\n// ============================================\r\n// INTELLIGENCE DOCUMENTS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo documento de inteligência na subcoleção da marca.\r\n */\r\nexport async function createIntelligenceDocument(data: CreateIntelligenceInput): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const expiresAt = calculateExpiresAt(data.type, now);\r\n  \r\n  // Gerar hash para deduplicação (será preenchido pelo Scout, mas garantimos aqui se necessário)\r\n  const textHash = (data.content as any).textHash || await generateHash(data.content.text);\r\n\r\n  const docData: Omit<IntelligenceDocument, 'id'> = {\r\n    brandId: data.brandId,\r\n    type: data.type,\r\n    status: 'raw',\r\n    source: data.source,\r\n    content: {\r\n      ...data.content,\r\n      textHash,\r\n    },\r\n    metrics: data.metrics,\r\n    collectedAt: now,\r\n    expiresAt,\r\n    version: 1,\r\n  };\r\n\r\n  const intelligenceRef = collection(db, 'brands', data.brandId, 'intelligence');\r\n  const docRef = await addDoc(intelligenceRef, docData);\r\n  \r\n  return docRef.id;\r\n}\r\n\r\n/**\r\n * Busca documentos de inteligência com filtros.\r\n */\r\nexport async function queryIntelligence(filters: IntelligenceQueryFilter): Promise<IntelligenceQueryResult> {\r\n  const intelligenceRef = collection(db, 'brands', filters.brandId, 'intelligence');\r\n  let q = query(intelligenceRef);\r\n\r\n  if (filters.types && filters.types.length > 0) {\r\n    q = query(q, where('type', 'in', filters.types));\r\n  }\r\n\r\n  if (filters.status && filters.status.length > 0) {\r\n    q = query(q, where('status', 'in', filters.status));\r\n  }\r\n\r\n  if (filters.dateRange) {\r\n    q = query(q, \r\n      where('collectedAt', '>=', filters.dateRange.start),\r\n      where('collectedAt', '<=', filters.dateRange.end)\r\n    );\r\n  }\r\n\r\n  if (filters.textHash) {\r\n    q = query(q, where('content.textHash', '==', filters.textHash));\r\n  }\r\n\r\n  const orderField = filters.orderBy || 'collectedAt';\r\n  const orderDirection = filters.orderDirection || 'desc';\r\n  q = query(q, orderBy(orderField, orderDirection));\r\n\r\n  if (filters.limit) {\r\n    q = query(q, limit(filters.limit));\r\n  }\r\n\r\n  const snapshot = await getDocs(q);\r\n  const documents = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as IntelligenceDocument));\r\n\r\n  return {\r\n    documents,\r\n    total: documents.length,\r\n    hasMore: false, // Implementar paginação real se necessário\r\n  };\r\n}\r\n\r\n/**\r\n * Atualiza um documento de inteligência (ex: após processamento do Analyst).\r\n */\r\nexport async function updateIntelligenceDocument(\r\n  brandId: string, \r\n  docId: string, \r\n  data: Partial<IntelligenceDocument>\r\n) {\r\n  const docRef = doc(db, 'brands', brandId, 'intelligence', docId);\r\n  await withResilience(async () => {\r\n    await updateDoc(docRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    });\r\n  });\r\n}\r\n\r\n// ============================================\r\n// INTELLIGENCE CONFIG (KEYWORDS)\r\n// ============================================\r\n\r\n/**\r\n * Busca a configuração de keywords de uma marca.\r\n */\r\nexport async function getBrandKeywordsConfig(brandId: string): Promise<BrandKeywordsConfig | null> {\r\n  const configRef = doc(db, 'brands', brandId, 'intelligence', '_config', 'keywords');\r\n  const snap = await getDoc(configRef);\r\n  \r\n  if (!snap.exists()) return null;\r\n  \r\n  return snap.data() as BrandKeywordsConfig;\r\n}\r\n\r\n/**\r\n * Salva ou atualiza a configuração de keywords.\r\n */\r\nexport async function saveBrandKeywordsConfig(brandId: string, config: Partial<BrandKeywordsConfig>) {\r\n  const configRef = doc(db, 'brands', brandId, 'intelligence', '_config', 'keywords');\r\n  const now = Timestamp.now();\r\n  \r\n  await setDoc(configRef, {\r\n    ...config,\r\n    brandId,\r\n    updatedAt: now,\r\n    version: (config.version || 0) + 1,\r\n  }, { merge: true });\r\n}\r\n\r\n// ============================================\r\n// HELPERS\r\n// ============================================\r\n\r\nfunction calculateExpiresAt(type: string, collectedAt: Timestamp): Timestamp {\r\n  const date = collectedAt.toDate();\r\n  let days = 30; // Default\r\n\r\n  switch (type) {\r\n    case 'mention': days = 30; break;\r\n    case 'trend': days = 90; break;\r\n    case 'competitor': days = 60; break;\r\n    case 'news': days = 14; break;\r\n  }\r\n\r\n  date.setDate(date.getDate() + days);\r\n  return Timestamp.fromDate(date);\r\n}\r\n\r\nasync function generateHash(text: string): Promise<string> {\r\n  // Simples hash para o lado do cliente se necessário, \r\n  // mas o Scout deve usar crypto-js no Node/Edge\r\n  return text.substring(0, 10) + text.length; \r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[4,5,6,7,8,9]}
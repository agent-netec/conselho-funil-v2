{"version":3,"sources":["../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/resilience.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/firestore.ts"],"sourcesContent":["import { \r\n  FirestoreError,\r\n} from 'firebase/firestore';\r\n\r\n/**\r\n * Opções para a estratégia de resiliência.\r\n */\r\ninterface ResilienceOptions {\r\n  maxRetries?: number;\r\n  initialDelay?: number;\r\n  maxDelay?: number;\r\n  factor?: number;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Required<ResilienceOptions> = {\r\n  maxRetries: 3,\r\n  initialDelay: 1000,\r\n  maxDelay: 10000,\r\n  factor: 2,\r\n};\r\n\r\n/**\r\n * Erros do Firestore que são considerados transientes e seguros para tentar novamente.\r\n * Ref: https://firebase.google.com/docs/firestore/manage-data/error-handling\r\n */\r\nconst RETRYABLE_ERROR_CODES = [\r\n  'aborted',\r\n  'deadline-exceeded',\r\n  'resource-exhausted',\r\n  'unavailable',\r\n  'internal',\r\n];\r\n\r\n/**\r\n * Executa uma operação do Firestore com estratégia de retry e exponential backoff.\r\n * \r\n * @param operation - A função assíncrona que executa a operação do Firestore.\r\n * @param options - Configurações de retry.\r\n * @returns O resultado da operação.\r\n */\r\nexport async function withResilience<T>(\r\n  operation: () => Promise<T>,\r\n  options: ResilienceOptions = {}\r\n): Promise<T> {\r\n  const { maxRetries, initialDelay, maxDelay, factor } = {\r\n    ...DEFAULT_OPTIONS,\r\n    ...options,\r\n  };\r\n\r\n  let lastError: any;\r\n  let delay = initialDelay;\r\n\r\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n    try {\r\n      return await operation();\r\n    } catch (error: any) {\r\n      lastError = error;\r\n\r\n      // Verifica se o erro é transiente\r\n      const isRetryable = error instanceof FirestoreError && RETRYABLE_ERROR_CODES.includes(error.code);\r\n      \r\n      if (!isRetryable || attempt === maxRetries) {\r\n        break;\r\n      }\r\n\r\n      console.warn(\r\n        `[Resilience] Falha na operação (tentativa ${attempt + 1}/${maxRetries + 1}). ` +\r\n        `Erro: ${error.code}. Tentando novamente em ${delay}ms...`\r\n      );\r\n\r\n      await new Promise((resolve) => setTimeout(resolve, delay));\r\n      delay = Math.min(delay * factor, maxDelay);\r\n    }\r\n  }\r\n\r\n  console.error('[Resilience] Operação falhou permanentemente após retries.', lastError);\r\n  throw lastError;\r\n}\r\n\r\n/**\r\n * Função utilitária para salvar métricas em lote (batching) com consistência eventual.\r\n * Útil para picos de carga onde não queremos sobrecarregar o Firestore com escritas individuais.\r\n */\r\nexport class PersistenceQueue {\r\n  private queue: Array<{ id: string; data: any; collection: string }> = [];\r\n  private timer: NodeJS.Timeout | null = null;\r\n  private readonly BATCH_DELAY = 2000; // 2 segundos de acumulação\r\n\r\n  constructor(private saveFn: (batch: any[]) => Promise<void>) {}\r\n\r\n  add(id: string, collection: string, data: any) {\r\n    this.queue.push({ id, collection, data });\r\n    \r\n    if (!this.timer) {\r\n      this.timer = setTimeout(() => this.flush(), this.BATCH_DELAY);\r\n    }\r\n  }\r\n\r\n  private async flush() {\r\n    if (this.queue.length === 0) return;\r\n\r\n    const currentBatch = [...this.queue];\r\n    this.queue = [];\r\n    this.timer = null;\r\n\r\n    try {\r\n      await withResilience(() => this.saveFn(currentBatch));\r\n    } catch (error) {\r\n      console.error('[PersistenceQueue] Erro ao processar lote de persistência:', error);\r\n      // Opcional: Re-adicionar à fila ou salvar em localStorage para retry posterior\r\n    }\r\n  }\r\n}\r\n","import {\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  setDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  addDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  Timestamp,\r\n  onSnapshot,\r\n  DocumentReference,\r\n  increment,\r\n} from 'firebase/firestore';\r\nimport { db } from './config';\r\nimport { withResilience } from './resilience';\r\nimport { encryptSensitiveFields } from '../utils/encryption';\r\nimport type {\r\n  User,\r\n  Tenant,\r\n  Funnel,\r\n  FunnelContext,\r\n  Proposal,\r\n  Decision,\r\n  Conversation,\r\n  Message,\r\n  LibraryTemplate,\r\n  Brand,\r\n  DashboardStats,\r\n  Integration,\r\n} from '@/types/database';\r\nimport type { CampaignContext } from '@/types/campaign';\r\n\r\n// ============================================\r\n// USERS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo documento de usuário no Firestore.\r\n * \r\n * @param userId - O UID do usuário vindo do Firebase Auth.\r\n * @param data - Dados básicos do usuário (nome, e-mail, etc.).\r\n * @returns O ID do usuário criado.\r\n */\r\nexport async function createUser(userId: string, data: Omit<User, 'id' | 'createdAt' | 'lastLogin' | 'credits' | 'usage'>) {\r\n  const userRef = doc(db, 'users', userId);\r\n  const now = Timestamp.now();\r\n  \r\n  await setDoc(userRef, {\r\n    ...data,\r\n    credits: 10, // MVP Default: 10 credits (US-16.1)\r\n    usage: 0,\r\n    createdAt: now,\r\n    lastLogin: now,\r\n  });\r\n  \r\n  return userId;\r\n}\r\n\r\n/**\r\n * Busca o saldo de créditos do usuário.\r\n * US-16.1\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns O saldo de créditos ou 0 se não encontrar.\r\n */\r\nexport async function getUserCredits(userId: string): Promise<number> {\r\n  const userRef = doc(db, 'users', userId);\r\n  const userSnap = await getDoc(userRef);\r\n  \r\n  if (!userSnap.exists()) return 0;\r\n  \r\n  const userData = userSnap.data();\r\n  return userData.credits ?? 0;\r\n}\r\n\r\n/**\r\n * Atualiza os créditos e o uso do usuário de forma atômica.\r\n * US-16.1\r\n * \r\n * @param userId - O ID do usuário.\r\n * @param amount - Quantidade a incrementar/decrementar (ex: -1).\r\n */\r\nexport async function updateUserUsage(userId: string, amount: number = -1) {\r\n  const userRef = doc(db, 'users', userId);\r\n  await updateDoc(userRef, {\r\n    credits: increment(amount),\r\n    usage: increment(Math.abs(amount)),\r\n  });\r\n}\r\n\r\n/**\r\n * Define uma quantidade específica de créditos para o usuário.\r\n * US-16.3 (Apenas para Dev Mode)\r\n * \r\n * @param userId - O ID do usuário.\r\n * @param amount - Quantidade de créditos.\r\n */\r\nexport async function setCredits(userId: string, amount: number) {\r\n  const userRef = doc(db, 'users', userId);\r\n  await updateDoc(userRef, {\r\n    credits: amount,\r\n  });\r\n}\r\n\r\n/**\r\n * Busca os dados de um usuário pelo ID.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Os dados do usuário ou null se não for encontrado.\r\n */\r\nexport async function getUser(userId: string): Promise<User | null> {\r\n  const userRef = doc(db, 'users', userId);\r\n  const userSnap = await getDoc(userRef);\r\n  \r\n  if (!userSnap.exists()) return null;\r\n  \r\n  return { id: userSnap.id, ...userSnap.data() } as User;\r\n}\r\n\r\n/**\r\n * Atualiza o timestamp de último login do usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n */\r\nexport async function updateUserLastLogin(userId: string) {\r\n  const userRef = doc(db, 'users', userId);\r\n  await updateDoc(userRef, { lastLogin: Timestamp.now() });\r\n}\r\n\r\n// ============================================\r\n// TENANTS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo tenant (organização/conta multi-tenant).\r\n * \r\n * @param data - Dados do tenant.\r\n * @returns O ID do tenant criado.\r\n */\r\nexport async function createTenant(data: Omit<Tenant, 'id' | 'createdAt' | 'updatedAt'>) {\r\n  const now = Timestamp.now();\r\n  const tenantRef = await addDoc(collection(db, 'tenants'), {\r\n    ...data,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n  \r\n  return tenantRef.id;\r\n}\r\n\r\n/**\r\n * Busca os dados de um tenant pelo ID.\r\n * \r\n * @param tenantId - O ID do tenant.\r\n * @returns Os dados do tenant ou null se não encontrado.\r\n */\r\nexport async function getTenant(tenantId: string): Promise<Tenant | null> {\r\n  const tenantRef = doc(db, 'tenants', tenantId);\r\n  const tenantSnap = await getDoc(tenantRef);\r\n  \r\n  if (!tenantSnap.exists()) return null;\r\n  \r\n  return { id: tenantSnap.id, ...tenantSnap.data() } as Tenant;\r\n}\r\n\r\n// ============================================\r\n// FUNNELS\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo funil de vendas.\r\n * \r\n * @param data - Dados de criação do funil, incluindo contexto e vinculação de usuário/tenant/marca.\r\n * @returns O ID do funil criado.\r\n */\r\nexport async function createFunnel(data: {\r\n  userId: string;\r\n  tenantId?: string;\r\n  name: string;\r\n  description?: string;\r\n  context: FunnelContext;\r\n  brandId?: string;\r\n}): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const funnelRef = await addDoc(collection(db, 'funnels'), {\r\n    ...data,\r\n    status: 'draft',\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n  \r\n  return funnelRef.id;\r\n}\r\n\r\n/**\r\n * Busca um funil específico pelo ID.\r\n * \r\n * @param funnelId - O ID do funil.\r\n * @returns O objeto Funnel ou null se não encontrado.\r\n */\r\nexport async function getFunnel(funnelId: string): Promise<Funnel | null> {\r\n  const funnelRef = doc(db, 'funnels', funnelId);\r\n  const funnelSnap = await getDoc(funnelRef);\r\n  \r\n  if (!funnelSnap.exists()) return null;\r\n  \r\n  return { id: funnelSnap.id, ...funnelSnap.data() } as Funnel;\r\n}\r\n\r\n/**\r\n * Recupera todos os funis pertencentes a um usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Array de funis ordenados pela última atualização.\r\n */\r\nexport async function getUserFunnels(userId: string): Promise<Funnel[]> {\r\n  // ST-11.6: Simplified query to avoid composite index (INC-004)\r\n  const q = query(\r\n    collection(db, 'funnels'),\r\n    where('userId', '==', userId)\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Funnel));\r\n  \r\n  // Sort in memory\r\n  return data.sort((a, b) => {\r\n    const dateA = a.updatedAt?.seconds || 0;\r\n    const dateB = b.updatedAt?.seconds || 0;\r\n    return dateB - dateA;\r\n  });\r\n}\r\n\r\n/**\r\n * Atualiza os dados de um funil existente.\r\n * Implementa resiliência via retry (ST-11.23).\r\n * \r\n * @param funnelId - O ID do funil.\r\n * @param data - Objeto parcial com os dados a serem atualizados.\r\n */\r\nexport async function updateFunnel(funnelId: string, data: Partial<Funnel>) {\r\n  const funnelRef = doc(db, 'funnels', funnelId);\r\n  await withResilience(async () => {\r\n    await updateDoc(funnelRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Exclui um funil permanentemente.\r\n * \r\n * @param funnelId - O ID do funil.\r\n */\r\nexport async function deleteFunnel(funnelId: string) {\r\n  const funnelRef = doc(db, 'funnels', funnelId);\r\n  await deleteDoc(funnelRef);\r\n}\r\n\r\n// ============================================\r\n// PROPOSALS (subcollection)\r\n// ============================================\r\n\r\n/**\r\n * Cria uma nova proposta estratégica vinculada a um funil.\r\n * Propostas são armazenadas como uma subcoleção do funil.\r\n * \r\n * @param funnelId - O ID do funil pai.\r\n * @param data - Dados da proposta estratégica.\r\n * @returns O ID da proposta criada.\r\n */\r\nexport async function createProposal(\r\n  funnelId: string,\r\n  data: Omit<Proposal, 'id' | 'funnelId' | 'createdAt'>\r\n): Promise<string> {\r\n  const proposalRef = await addDoc(\r\n    collection(db, 'funnels', funnelId, 'proposals'),\r\n    {\r\n      ...data,\r\n      funnelId,\r\n      createdAt: Timestamp.now(),\r\n    }\r\n  );\r\n  \r\n  return proposalRef.id;\r\n}\r\n\r\n/**\r\n * Recupera todas as propostas estratégicas de um funil.\r\n * \r\n * @param funnelId - O ID do funil.\r\n * @returns Array de propostas ordenadas pela versão (decrescente).\r\n */\r\nexport async function getFunnelProposals(funnelId: string): Promise<Proposal[]> {\r\n  const q = query(\r\n    collection(db, 'funnels', funnelId, 'proposals'),\r\n    orderBy('version', 'desc')\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Proposal));\r\n}\r\n\r\n// ============================================\r\n// DECISIONS (subcollection)\r\n// ============================================\r\n\r\n/**\r\n * Registra uma decisão tomada pelo usuário sobre um funil (aprovação, morte, etc.).\r\n * \r\n * @param funnelId - O ID do funil relacionado.\r\n * @param data - Detalhes da decisão e justificativa.\r\n * @returns O ID do registro da decisão.\r\n */\r\nexport async function createDecision(\r\n  funnelId: string,\r\n  data: Omit<Decision, 'id' | 'funnelId' | 'createdAt'>\r\n): Promise<string> {\r\n  const decisionRef = await addDoc(\r\n    collection(db, 'funnels', funnelId, 'decisions'),\r\n    {\r\n      ...data,\r\n      funnelId,\r\n      createdAt: Timestamp.now(),\r\n    }\r\n  );\r\n  \r\n  return decisionRef.id;\r\n}\r\n\r\n// ============================================\r\n// CONVERSATIONS\r\n// ============================================\r\n\r\n/**\r\n * Inicia uma nova conversa no chat.\r\n * \r\n * @param data - Dados básicos da conversa (usuário, título, contexto, marca).\r\n * @returns O ID da conversa criada.\r\n */\r\nexport async function createConversation(data: {\r\n  userId: string;\r\n  tenantId?: string;\r\n  title: string;\r\n  context?: Conversation['context'];\r\n  brandId?: string;\r\n}): Promise<string> {\r\n  const now = Timestamp.now();\r\n  \r\n  // US-20.2: Remover campos undefined para evitar erro do Firestore\r\n  const cleanData = Object.fromEntries(\r\n    Object.entries(data).filter(([_, v]) => v !== undefined)\r\n  );\r\n\r\n  const convRef = await addDoc(collection(db, 'conversations'), {\r\n    ...cleanData,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n  \r\n  return convRef.id;\r\n}\r\n\r\n/**\r\n * Busca uma conversa específica pelo ID.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @returns O objeto Conversation ou null se não encontrada.\r\n */\r\nexport async function getConversation(conversationId: string): Promise<Conversation | null> {\r\n  const convRef = doc(db, 'conversations', conversationId);\r\n  const convSnap = await getDoc(convRef);\r\n  \r\n  if (!convSnap.exists()) return null;\r\n  \r\n  return { id: convSnap.id, ...convSnap.data() } as Conversation;\r\n}\r\n\r\n/**\r\n * Recupera as conversas recentes de um usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Array das últimas 50 conversas.\r\n */\r\nexport async function getUserConversations(userId: string): Promise<Conversation[]> {\r\n  // ST-11.6: Simplified query to avoid composite index (INC-004)\r\n  const q = query(\r\n    collection(db, 'conversations'),\r\n    where('userId', '==', userId),\r\n    limit(50)\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Conversation));\r\n  \r\n  // Sort in memory\r\n  return data.sort((a, b) => {\r\n    const dateA = a.updatedAt?.seconds || 0;\r\n    const dateB = b.updatedAt?.seconds || 0;\r\n    return dateB - dateA;\r\n  });\r\n}\r\n\r\n/**\r\n * Atualiza metadados de uma conversa (ex: título).\r\n * Implementa resiliência via retry (ST-11.23).\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @param data - Campos parciais a atualizar.\r\n */\r\nexport async function updateConversation(conversationId: string, data: Partial<Conversation>) {\r\n  const convRef = doc(db, 'conversations', conversationId);\r\n  await withResilience(async () => {\r\n    await updateDoc(convRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Exclui uma conversa permanentemente.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n */\r\nexport async function deleteConversation(conversationId: string) {\r\n  const convRef = doc(db, 'conversations', conversationId);\r\n  await deleteDoc(convRef);\r\n}\r\n\r\n// ============================================\r\n// MESSAGES (subcollection)\r\n// ============================================\r\n\r\n/**\r\n * Adiciona uma mensagem a uma conversa.\r\n * Também atualiza o timestamp de atualização da conversa pai.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @param data - Conteúdo da mensagem e remetente.\r\n * @returns O ID da mensagem criada.\r\n */\r\nexport async function addMessage(\r\n  conversationId: string,\r\n  data: Omit<Message, 'id' | 'conversationId' | 'createdAt'>\r\n): Promise<string> {\r\n  const messageRef = await addDoc(\r\n    collection(db, 'conversations', conversationId, 'messages'),\r\n    {\r\n      ...data,\r\n      conversationId,\r\n      createdAt: Timestamp.now(),\r\n    }\r\n  );\r\n  \r\n  // Update conversation's updatedAt\r\n  await updateConversation(conversationId, {});\r\n  \r\n  return messageRef.id;\r\n}\r\n\r\n/**\r\n * Recupera todas as mensagens de uma conversa.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @returns Array de mensagens ordenadas cronologicamente.\r\n */\r\nexport async function getConversationMessages(conversationId: string): Promise<Message[]> {\r\n  const q = query(\r\n    collection(db, 'conversations', conversationId, 'messages'),\r\n    orderBy('createdAt', 'asc')\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message));\r\n}\r\n\r\n/**\r\n * Cria uma inscrição (listener) para receber atualizações de mensagens em tempo real.\r\n * \r\n * @param conversationId - O ID da conversa.\r\n * @param callback - Função executada a cada atualização da lista de mensagens.\r\n * @returns Função para cancelar a inscrição.\r\n */\r\nexport function subscribeToMessages(\r\n  conversationId: string,\r\n  callback: (messages: Message[]) => void\r\n) {\r\n  const q = query(\r\n    collection(db, 'conversations', conversationId, 'messages'),\r\n    orderBy('createdAt', 'asc')\r\n  );\r\n  \r\n  return onSnapshot(q, (snapshot) => {\r\n    const messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Message));\r\n    callback(messages);\r\n  });\r\n}\r\n\r\n// ============================================\r\n// LIBRARY TEMPLATES\r\n// ============================================\r\n\r\n/**\r\n * Busca modelos da biblioteca com filtros opcionais.\r\n * \r\n * @param filters - Filtros por tipo de funil ou vertical de negócio.\r\n * @returns Array de modelos de biblioteca ordenados por popularidade.\r\n */\r\nexport async function getLibraryTemplates(\r\n  filters?: { type?: string; vertical?: string }\r\n): Promise<LibraryTemplate[]> {\r\n  let q = query(collection(db, 'library'), orderBy('usageCount', 'desc'));\r\n  \r\n  const snapshot = await getDocs(q);\r\n  let templates = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as LibraryTemplate));\r\n  \r\n  // Client-side filtering (Firestore doesn't support multiple inequality filters)\r\n  if (filters?.type) {\r\n    templates = templates.filter(t => t.type === filters.type);\r\n  }\r\n  \r\n  return templates;\r\n}\r\n\r\n/**\r\n * Salva um novo modelo na biblioteca pública ou privada.\r\n * \r\n * @param data - Dados do modelo (estrutura, descrição, tipo).\r\n * @returns O ID do modelo criado.\r\n */\r\nexport async function saveToLibrary(data: Omit<LibraryTemplate, 'id' | 'createdAt' | 'usageCount'>) {\r\n  const templateRef = await addDoc(collection(db, 'library'), {\r\n    ...data,\r\n    usageCount: 0,\r\n    createdAt: Timestamp.now(),\r\n  });\r\n  \r\n  return templateRef.id;\r\n}\r\n\r\n// ============================================\r\n// STATS (for dashboard)\r\n// ============================================\r\n\r\n/**\r\n * Consolida estatísticas de uso para o painel de controle do usuário.\r\n * \r\n * @param userId - O ID do usuário.\r\n * @returns Objeto com contagens de funis ativos, avaliações pendentes e decisões do mês.\r\n */\r\nexport async function getUserStats(userId: string): Promise<DashboardStats> {\r\n  const [funnels, conversations] = await Promise.all([\r\n    getUserFunnels(userId),\r\n    getUserConversations(userId),\r\n  ]);\r\n  \r\n  const activeFunnels = funnels.filter(f => \r\n    !['completed', 'killed'].includes(f.status)\r\n  ).length;\r\n  \r\n  const pendingEvaluations = funnels.filter(f => \r\n    f.status === 'review'\r\n  ).length;\r\n  \r\n  const decisionsThisMonth = funnels.filter(f => {\r\n    const createdAt = f.createdAt.toDate();\r\n    const now = new Date();\r\n    return (\r\n      createdAt.getMonth() === now.getMonth() &&\r\n      createdAt.getFullYear() === now.getFullYear() &&\r\n      ['approved', 'killed', 'adjusting'].includes(f.status)\r\n    );\r\n  }).length;\r\n  \r\n  // US-1.5.3: Benchmarks devem ser carregados via API ou Server Action para evitar vazamento de 'fs' para o cliente.\r\n  const performance_benchmarks = [\r\n    { metric: 'CPC Médio', value: '--', benchmark_2026: 'R$ 0,50', status: 'neutral' as const },\r\n    { metric: 'CTR Global', value: '--', benchmark_2026: '2.5%', status: 'neutral' as const },\r\n    { metric: 'ROAS Alvo', value: '--', benchmark_2026: '4.0x', status: 'neutral' as const }\r\n  ];\r\n\r\n  return {\r\n    activeFunnels,\r\n    pendingEvaluations,\r\n    decisionsThisMonth,\r\n    totalConversations: conversations.length,\r\n    performance_benchmarks,\r\n  };\r\n}\r\n\r\n\r\n// ============================================\r\n// BRANDS\r\n// ============================================\r\n\r\n/**\r\n * Busca uma marca específica pelo ID.\r\n */\r\nexport async function getBrand(brandId: string): Promise<Brand | null> {\r\n  const brandRef = doc(db, 'brands', brandId);\r\n  const brandSnap = await getDoc(brandRef);\r\n  \r\n  if (!brandSnap.exists()) return null;\r\n  \r\n  return { id: brandSnap.id, ...brandSnap.data() } as Brand;\r\n}\r\n\r\n/**\r\n * Atualiza os dados de uma marca.\r\n */\r\nexport async function updateBrand(brandId: string, data: Partial<Brand>) {\r\n  const brandRef = doc(db, 'brands', brandId);\r\n  await updateDoc(brandRef, {\r\n    ...data,\r\n    updatedAt: Timestamp.now(),\r\n  });\r\n}\r\n\r\n// ============================================\r\n// INTEGRATIONS\r\n// ============================================\r\n\r\n/**\r\n * Salva ou atualiza uma integração para um tenant.\r\n * \r\n * @param tenantId - O ID do tenant.\r\n * @param provider - O provedor da integração (ex: 'meta').\r\n * @param data - Configurações da integração.\r\n */\r\nexport async function saveIntegration(\r\n  tenantId: string,\r\n  provider: Integration['provider'],\r\n  data: any\r\n) {\r\n  const integrationId = provider; // Usamos o provider como ID fixo por enquanto (um por tipo)\r\n  const integrationRef = doc(db, 'tenants', tenantId, 'integrations', integrationId);\r\n  const now = Timestamp.now();\r\n\r\n  // ST-18.6: Criptografia de tokens sensíveis antes de salvar no Firestore\r\n  const secureConfig = encryptSensitiveFields(data);\r\n\r\n  const integrationData = {\r\n    id: integrationId,\r\n    tenantId,\r\n    provider,\r\n    status: 'active' as const,\r\n    config: secureConfig,\r\n    updatedAt: now,\r\n  };\r\n\r\n  // Tenta buscar se já existe para manter o createdAt\r\n  const snap = await getDoc(integrationRef);\r\n  if (snap.exists()) {\r\n    await updateDoc(integrationRef, integrationData);\r\n  } else {\r\n    await setDoc(integrationRef, {\r\n      ...integrationData,\r\n      createdAt: now,\r\n    });\r\n  }\r\n\r\n  return integrationId;\r\n}\r\n\r\n/**\r\n * Busca todas as integrações de um tenant.\r\n * \r\n * @param tenantId - O ID do tenant.\r\n */\r\nexport async function getIntegrations(tenantId: string): Promise<Integration[]> {\r\n  const q = query(collection(db, 'tenants', tenantId, 'integrations'));\r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Integration));\r\n}\r\n\r\n// ============================================\r\n// CAMPAIGNS (Manifesto / Golden Thread)\r\n// ============================================\r\n\r\n/**\r\n * Cria uma nova campanha (Manifesto da Linha de Ouro) a partir de um funil aprovado.\r\n * Segue o contrato da ST-11.21: CampaignId != FunnelId.\r\n */\r\nexport async function createCampaign(data: {\r\n  funnelId: string;\r\n  userId: string;\r\n  brandId: string;\r\n  name: string;\r\n  funnelData: CampaignContext['funnel'];\r\n}): Promise<string> {\r\n  const timestamp = Date.now();\r\n  const shortId = Math.random().toString(36).substring(2, 7);\r\n  const campaignId = `${data.funnelId}_${timestamp}_${shortId}`;\r\n  \r\n  const now = Timestamp.now();\r\n  const campaignRef = doc(db, 'campaigns', campaignId);\r\n  \r\n  const campaignData: CampaignContext = {\r\n    id: campaignId,\r\n    funnelId: data.funnelId,\r\n    userId: data.userId,\r\n    brandId: data.brandId,\r\n    name: data.name,\r\n    status: 'planning',\r\n    funnel: data.funnelData,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  };\r\n  \r\n  await setDoc(campaignRef, campaignData);\r\n  return campaignId;\r\n}\r\n\r\n/**\r\n * Busca uma campanha pelo ID.\r\n */\r\nexport async function getCampaign(campaignId: string): Promise<CampaignContext | null> {\r\n  const campaignRef = doc(db, 'campaigns', campaignId);\r\n  const campaignSnap = await getDoc(campaignRef);\r\n  \r\n  if (!campaignSnap.exists()) return null;\r\n  \r\n  return { id: campaignSnap.id, ...campaignSnap.data() } as CampaignContext;\r\n}\r\n\r\n/**\r\n * Atualiza o manifesto de uma campanha de forma atômica (Upsert).\r\n * Implementa resiliência via retry e backoff (ST-11.23).\r\n */\r\nexport async function updateCampaignManifesto(\r\n  campaignId: string, \r\n  data: Partial<CampaignContext>\r\n) {\r\n  const campaignRef = doc(db, 'campaigns', campaignId);\r\n  \r\n  return await withResilience(async () => {\r\n    await setDoc(campaignRef, {\r\n      ...data,\r\n      updatedAt: Timestamp.now(),\r\n    }, { merge: true });\r\n  });\r\n}\r\n\r\n\r\n"],"names":[],"mappings":"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"}
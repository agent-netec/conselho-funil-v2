{"version":3,"sources":["../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/assets.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/storage.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/ai/brand-governance.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/ai/pinecone.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/firebase/vault.ts","../../../../../../../../OneDrive/Desktop/CURSOR/CONSELHO%20DE%20FUNIL/app/src/lib/vault/pinecone-vault.ts"],"sourcesContent":["import {\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  addDoc,\r\n  updateDoc,\r\n  deleteDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  Timestamp,\r\n  writeBatch,\r\n} from 'firebase/firestore';\r\nimport { db } from './config';\r\nimport { deleteBrandAssetFromStorage } from './storage';\r\nimport { logAudit } from '../ai/brand-governance';\r\nimport type { BrandAsset } from '../../types/database';\r\n\r\n// ============================================\r\n// BRAND ASSETS - Gerenciamento de Arquivos\r\n// ============================================\r\n\r\nexport interface BrandAssetWithId extends BrandAsset {\r\n  id: string;\r\n}\r\n\r\n/**\r\n * Busca um asset específico pelo ID. (Alias para compatibilidade com o worker)\r\n */\r\nexport async function fetchBrandAsset(assetId: string): Promise<BrandAssetWithId | null> {\r\n  return getAsset(assetId) as Promise<BrandAssetWithId | null>;\r\n}\r\n\r\n/**\r\n * Cria um novo registro de asset no Firestore.\r\n */\r\nexport async function createAsset(data: Omit<BrandAsset, 'id'>): Promise<string> {\r\n  const assetRef = await addDoc(collection(db, 'brand_assets'), {\r\n    ...data,\r\n    isApprovedForAI: data.isApprovedForAI ?? false,\r\n  });\r\n  return assetRef.id;\r\n}\r\n\r\n/**\r\n * Busca todos os assets de uma marca específica.\r\n */\r\nexport async function getBrandAssets(brandId: string): Promise<BrandAsset[]> {\r\n  const q = query(\r\n    collection(db, 'brand_assets'),\r\n    where('brandId', '==', brandId),\r\n    orderBy('createdAt', 'desc')\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as BrandAsset));\r\n}\r\n\r\n/**\r\n * Busca um asset específico pelo ID.\r\n */\r\nexport async function getAsset(assetId: string): Promise<BrandAsset | null> {\r\n  const assetRef = doc(db, 'brand_assets', assetId);\r\n  const assetSnap = await getDoc(assetRef);\r\n  \r\n  if (!assetSnap.exists()) return null;\r\n  \r\n  return { id: assetSnap.id, ...assetSnap.data() } as BrandAsset;\r\n}\r\n\r\n/**\r\n * Atualiza o status de um asset.\r\n */\r\nexport async function updateAssetStatus(\r\n  assetId: string,\r\n  status: BrandAsset['status'],\r\n  error?: string\r\n): Promise<void> {\r\n  const assetRef = doc(db, 'brand_assets', assetId);\r\n  const updates: Partial<BrandAsset> = { status };\r\n  \r\n  if (status === 'ready') {\r\n    updates.processedAt = Timestamp.now();\r\n  }\r\n  \r\n  if (error) {\r\n    updates.processingError = error;\r\n  }\r\n  \r\n  await updateDoc(assetRef, updates);\r\n}\r\n\r\n/**\r\n * Atualiza dados de um asset existente.\r\n */\r\nexport async function updateAsset(\r\n  assetId: string,\r\n  data: Partial<Omit<BrandAsset, 'id' | 'brandId' | 'userId' | 'createdAt'>>\r\n): Promise<void> {\r\n  const assetRef = doc(db, 'brand_assets', assetId);\r\n  await updateDoc(assetRef, data);\r\n}\r\n\r\n/**\r\n * Alias para compatibilidade com o worker.\r\n */\r\nexport async function updateBrandAsset(\r\n  assetId: string,\r\n  data: Partial<BrandAsset> & { status?: BrandAsset['status']; chunkCount?: number; processedAt?: Timestamp; processingError?: string | null }\r\n) {\r\n  const ref = doc(db, 'brand_assets', assetId);\r\n  await updateDoc(ref, data as Record<string, unknown>);\r\n}\r\n\r\n/**\r\n * Alterna o status de aprovação de um asset para a IA.\r\n */\r\nexport async function toggleAssetApproval(\r\n  assetId: string,\r\n  isApproved: boolean,\r\n  userId: string\r\n): Promise<void> {\r\n  const assetRef = doc(db, 'brand_assets', assetId);\r\n  const assetSnap = await getDoc(assetRef);\r\n  \r\n  if (!assetSnap.exists()) {\r\n    throw new Error('Asset não encontrado');\r\n  }\r\n\r\n  const assetData = assetSnap.data() as BrandAsset;\r\n\r\n  await updateDoc(assetRef, { isApprovedForAI: isApproved });\r\n\r\n  await logAudit(\r\n    assetData.brandId, \r\n    isApproved ? 'APPROVE_ASSET_AI' : 'REVOKE_ASSET_AI', \r\n    { assetId, assetName: assetData.name }, \r\n    userId\r\n  );\r\n\r\n  const chunksCollectionRef = collection(db, 'brand_assets', assetId, 'chunks');\r\n  const chunksSnap = await getDocs(chunksCollectionRef);\r\n  \r\n  if (!chunksSnap.empty) {\r\n    const batch = writeBatch(db);\r\n    chunksSnap.docs.forEach((chunkDoc) => {\r\n      batch.update(chunkDoc.ref, {\r\n        'metadata.isApprovedForAI': isApproved\r\n      });\r\n    });\r\n    await batch.commit();\r\n  }\r\n}\r\n\r\n/**\r\n * Deleta um asset permanentemente (Firestore + Storage).\r\n */\r\nexport async function deleteAsset(assetId: string, storageUrl: string): Promise<void> {\r\n  try {\r\n    await deleteBrandAssetFromStorage(storageUrl);\r\n  } catch (error) {\r\n    console.error('Erro ao deletar do Storage:', error);\r\n  }\r\n  \r\n  const assetRef = doc(db, 'brand_assets', assetId);\r\n  await deleteDoc(assetRef);\r\n}\r\n\r\n/**\r\n * Busca assets por tipo específico.\r\n */\r\nexport async function getAssetsByType(\r\n  brandId: string,\r\n  type: BrandAsset['type']\r\n): Promise<BrandAsset[]> {\r\n  const q = query(\r\n    collection(db, 'brand_assets'),\r\n    where('brandId', '==', brandId),\r\n    where('type', '==', type),\r\n    orderBy('createdAt', 'desc')\r\n  );\r\n  \r\n  const snapshot = await getDocs(q);\r\n  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as BrandAsset));\r\n}\r\n\r\n// O processamento de chunks foi movido para assets-server.ts para evitar erros de build no cliente.\r\n\r\n","import {\r\n  ref,\r\n  uploadBytesResumable,\r\n  uploadString,\r\n  getDownloadURL,\r\n  deleteObject,\r\n  type UploadMetadata,\r\n} from 'firebase/storage';\r\nimport { storage } from './config';\r\nimport { createVaultAsset } from './vault';\r\n\r\n/**\r\n * Faz upload de um asset para o Vault (Creative Vault).\r\n * Sincroniza metadados no Firestore após o upload.\r\n */\r\nexport async function uploadVaultAsset(\r\n  file: File,\r\n  brandId: string,\r\n  userId: string,\r\n  tags: string[] = []\r\n): Promise<string> {\r\n  const timestamp = Date.now();\r\n  const fileName = `${timestamp}_${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;\r\n  const storagePath = `brands/${brandId}/vault/assets/${fileName}`;\r\n  const storageRef = ref(storage, storagePath);\r\n\r\n  const metadata: UploadMetadata = {\r\n    contentType: file.type,\r\n    customMetadata: {\r\n      userId,\r\n      brandId,\r\n      originalName: file.name,\r\n      uploadedAt: new Date().toISOString(),\r\n    },\r\n  };\r\n\r\n  const uploadTask = await uploadBytesResumable(storageRef, file, metadata);\r\n  const downloadURL = await getDownloadURL(uploadTask.ref);\r\n\r\n  // Determinar o tipo do asset\r\n  let type: 'image' | 'video' | 'logo' | 'document' = 'document';\r\n  if (file.type.startsWith('image/')) type = 'image';\r\n  else if (file.type.startsWith('video/')) type = 'video';\r\n\r\n  // Salvar metadados no Firestore (sub-coleção vault/assets)\r\n  await createVaultAsset(brandId, {\r\n    name: file.name,\r\n    type,\r\n    url: downloadURL,\r\n    storagePath,\r\n    status: 'approved', // Assets manuais são aprovados por padrão\r\n    tags,\r\n    metadata: {\r\n      size: file.size,\r\n      contentType: file.type,\r\n      uploadedBy: userId,\r\n    },\r\n  });\r\n\r\n  return downloadURL;\r\n}\r\n\r\n/**\r\n * Faz upload de uma imagem em Base64 (Data URL) para o Firebase Storage.\r\n */\r\nexport async function uploadBase64Image(\r\n  dataUrl: string,\r\n  brandId: string,\r\n  userId: string,\r\n  fileName: string\r\n): Promise<string> {\r\n  const storagePath = `brand-assets/${userId}/${brandId}/${Date.now()}_${fileName}`;\r\n  const storageRef = ref(storage, storagePath);\r\n  \r\n  // QA Hardening: Limpeza e conversão Data URL para Blob\r\n  try {\r\n    // Remove qualquer query parameter acidental que possa ter sido anexado à string Base64\r\n    const cleanDataUrl = dataUrl.split('&')[0].split('?')[0];\r\n    const res = await fetch(cleanDataUrl);\r\n    const blob = await res.blob();\r\n    \r\n    await uploadBytesResumable(storageRef, blob, {\r\n      contentType: blob.type,\r\n      customMetadata: {\r\n        userId,\r\n        brandId,\r\n        originalName: fileName,\r\n        uploadedAt: new Date().toISOString(),\r\n      },\r\n    });\r\n    \r\n    return await getDownloadURL(storageRef);\r\n  } catch (error) {\r\n    console.error('Erro ao processar binário da imagem para upload:', error);\r\n    throw new Error('Falha na conversão binária da imagem gerada.');\r\n  }\r\n}\r\n\r\n/**\r\n * Faz upload de uma logo de marca para o Firebase Storage.\r\n * US-18.2\r\n */\r\nexport async function uploadLogo(\r\n  file: File,\r\n  brandId: string,\r\n  userId: string\r\n): Promise<string> {\r\n  const timestamp = Date.now();\r\n  const fileExtension = file.name.split('.').pop();\r\n  const fileName = `logo_${timestamp}.${fileExtension}`;\r\n  \r\n  // Storage path pattern: brands/{userId}/{brandId}/logos/{fileName}\r\n  const storagePath = `brands/${userId}/${brandId}/logos/${fileName}`;\r\n  const storageRef = ref(storage, storagePath);\r\n  \r\n  const uploadTask = uploadBytesResumable(storageRef, file, {\r\n    contentType: file.type,\r\n  });\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    uploadTask.on(\r\n      'state_changed',\r\n      null,\r\n      (error) => reject(error),\r\n      async () => {\r\n        try {\r\n          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\r\n          resolve(downloadURL);\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Faz upload de um arquivo de brand asset para o Firebase Storage.\r\n * \r\n * @param file - O arquivo a ser enviado.\r\n * @param brandId - O ID da marca à qual o arquivo pertence.\r\n * @param userId - O ID do usuário que está fazendo o upload.\r\n * @param onProgress - Callback opcional para tracking do progresso (0-100).\r\n * @returns Promise com a URL pública do arquivo e metadata.\r\n * \r\n * @example\r\n * ```ts\r\n * const result = await uploadBrandAsset(file, 'brand_123', 'user_456', (progress) => {\r\n *   console.log(`Upload: ${progress}%`);\r\n * });\r\n * console.log('URL:', result.url);\r\n * ```\r\n */\r\nexport async function uploadBrandAsset(\r\n  file: File,\r\n  brandId: string,\r\n  userId: string,\r\n  onProgress?: (progress: number) => void\r\n): Promise<{ url: string; metadata: UploadMetadata }> {\r\n  // Gera um ID único para o arquivo\r\n  const timestamp = Date.now();\r\n  const sanitizedFileName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');\r\n  const fileName = `${timestamp}_${sanitizedFileName}`;\r\n  \r\n  // Storage path pattern: brand-assets/{userId}/{brandId}/{uniqueId}_{fileName}\r\n  const storagePath = `brand-assets/${userId}/${brandId}/${fileName}`;\r\n  const storageRef = ref(storage, storagePath);\r\n  \r\n  // Metadata do arquivo\r\n  const metadata: UploadMetadata = {\r\n    contentType: file.type,\r\n    customMetadata: {\r\n      userId,\r\n      brandId,\r\n      originalName: file.name,\r\n      uploadedAt: new Date().toISOString(),\r\n    },\r\n  };\r\n  \r\n  // Inicia o upload com tracking de progresso\r\n  const uploadTask = uploadBytesResumable(storageRef, file, metadata);\r\n  \r\n  return new Promise((resolve, reject) => {\r\n    uploadTask.on(\r\n      'state_changed',\r\n      (snapshot) => {\r\n        // Calcula e reporta o progresso\r\n        const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n        onProgress?.(Math.round(progress));\r\n      },\r\n      (error) => {\r\n        // Erro durante o upload\r\n        reject(error);\r\n      },\r\n      async () => {\r\n        // Upload completo - obter URL pública\r\n        try {\r\n          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);\r\n          resolve({\r\n            url: downloadURL,\r\n            metadata: uploadTask.snapshot.metadata as UploadMetadata,\r\n          });\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n * Remove um arquivo do Firebase Storage.\r\n * \r\n * @param storageUrl - URL completa do Firebase Storage (formato: gs:// ou https://).\r\n * \r\n * @example\r\n * ```ts\r\n * await deleteBrandAsset('https://firebasestorage.googleapis.com/...');\r\n * ```\r\n */\r\nexport async function deleteBrandAssetFromStorage(storageUrl: string): Promise<void> {\r\n  const storageRef = ref(storage, storageUrl);\r\n  await deleteObject(storageRef);\r\n}\r\n\r\n/**\r\n * Valida se um arquivo atende aos requisitos de upload.\r\n * \r\n * @param file - O arquivo a ser validado.\r\n * @returns Objeto com `valid` (boolean) e `error` (string opcional).\r\n * \r\n * @example\r\n * ```ts\r\n * const validation = validateBrandAssetFile(file);\r\n * if (!validation.valid) {\r\n *   alert(validation.error);\r\n * }\r\n * ```\r\n */\r\nexport function validateBrandAssetFile(file: File): { valid: boolean; error?: string } {\r\n  // Tipos permitidos\r\n  const allowedTypes = [\r\n    'application/pdf',\r\n    'application/x-pdf',\r\n    'application/vnd.pdf',\r\n    'application/msword',\r\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n    'text/plain',\r\n    'text/markdown',\r\n    'image/png',\r\n    'image/jpeg',\r\n    'image/webp',\r\n    'image/svg+xml',\r\n  ];\r\n  \r\n  const allowedExtensions = ['.pdf', '.doc', '.docx', '.txt', '.md', '.png', '.jpg', '.jpeg', '.webp', '.svg'];\r\n  \r\n  // Valida tipo MIME\r\n  if (!allowedTypes.includes(file.type)) {\r\n    const fileExtension = '.' + file.name.split('.').pop()?.toLowerCase();\r\n    if (!allowedExtensions.includes(fileExtension)) {\r\n      return {\r\n        valid: false,\r\n        error: `Formato não suportado. Use: ${allowedExtensions.join(', ')}`,\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Valida tamanho (10MB para documentos, 10MB para imagens) - US-13.8\r\n  const isImage = file.type.startsWith('image/');\r\n  const maxSize = isImage ? 10 * 1024 * 1024 : 10 * 1024 * 1024; // 10MB\r\n  \r\n  if (file.size > maxSize) {\r\n    const maxSizeMB = 10;\r\n    return {\r\n      valid: false,\r\n      error: `Arquivo muito grande. Máximo: ${maxSizeMB}MB`,\r\n    };\r\n  }\r\n\r\n  // Valida integridade básica (arquivos com 0 bytes ou sem nome)\r\n  if (file.size === 0) {\r\n    return {\r\n      valid: false,\r\n      error: 'O arquivo parece estar vazio ou corrompido.',\r\n    };\r\n  }\r\n  \r\n  return { valid: true };\r\n}\r\n\r\n","import { db } from '../firebase/config';\r\nimport { doc, getDoc, updateDoc, collection, addDoc, Timestamp } from 'firebase/firestore';\r\nimport type { Brand, LogoAsset } from '../../types/database';\r\n\r\n/**\r\n * Sanitiza conteúdo SVG para evitar XSS e remover scripts maliciosos.\r\n * Como não temos dompurify instalado, usamos uma abordagem baseada em Regex\r\n * para remover tags <script>, onAttributes e outros elementos perigosos.\r\n */\r\nexport function sanitizeSvg(svg: string): string {\r\n  if (!svg) return '';\r\n\r\n  return svg\r\n    .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '') // Remove <script> tags\r\n    .replace(/on\\w+=\"[^\"]*\"/gi, '') // Remove onEvent attributes (onclick, onload, etc.)\r\n    .replace(/on\\w+='[^']*'/gi, '')\r\n    .replace(/javascript:[^\"']*/gi, '') // Remove javascript: URIs\r\n    .replace(/<iframe\\b[^<]*(?:(?!<\\/iframe>)<[^<]*)*<\\/iframe>/gi, '') // Remove <iframe>\r\n    .replace(/<object\\b[^<]*(?:(?!<\\/object>)<[^<]*)*<\\/object>/gi, '') // Remove <object>\r\n    .trim();\r\n}\r\n\r\n/**\r\n * Registra um log de auditoria para alterações de marca.\r\n */\r\nexport async function logAudit(brandId: string, action: string, details: any, userId: string) {\r\n  try {\r\n    const auditRef = collection(db, 'brands', brandId, 'audit_logs');\r\n    await addDoc(auditRef, {\r\n      action,\r\n      details,\r\n      userId,\r\n      createdAt: Timestamp.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to log audit:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Atualiza um logo específico no BrandKit, respeitando a trava de segurança.\r\n */\r\nexport async function updateLogoLock(\r\n  brandId: string,\r\n  variant: 'primary' | 'horizontal' | 'icon',\r\n  asset: LogoAsset,\r\n  userId: string\r\n) {\r\n  const brandRef = doc(db, 'brands', brandId);\r\n  const brandSnap = await getDoc(brandRef);\r\n\r\n  if (!brandSnap.exists()) {\r\n    throw new Error('Marca não encontrada');\r\n  }\r\n\r\n  const brandData = brandSnap.data() as Brand;\r\n  \r\n  // Governança: Se estiver travado, bloqueia atualização\r\n  if (brandData.brandKit?.logoLock?.locked) {\r\n    throw new Error('Logo Lock ativo: Desbloqueie o BrandKit para alterar os logos oficiais.');\r\n  }\r\n\r\n  // Sanitização se for SVG\r\n  if (asset.format === 'svg' && asset.svgRaw) {\r\n    asset.svgRaw = sanitizeSvg(asset.svgRaw);\r\n  }\r\n\r\n  const updatedLogoLock = {\r\n    ...brandData.brandKit?.logoLock,\r\n    variants: {\r\n      ...brandData.brandKit?.logoLock?.variants,\r\n      [variant]: asset,\r\n    },\r\n    updatedAt: Timestamp.now(),\r\n  };\r\n\r\n  await updateDoc(brandRef, {\r\n    'brandKit.logoLock': updatedLogoLock,\r\n    updatedAt: Timestamp.now(),\r\n  });\r\n\r\n  await logAudit(brandId, `UPDATE_LOGO_${variant.toUpperCase()}`, { asset }, userId);\r\n}\r\n\r\n/**\r\n * Ativa ou desativa a trava global de governança de logos.\r\n */\r\nexport async function toggleLogoLock(\r\n  brandId: string,\r\n  locked: boolean,\r\n  userId: string\r\n) {\r\n  const brandRef = doc(db, 'brands', brandId);\r\n  \r\n  await updateDoc(brandRef, {\r\n    'brandKit.logoLock.locked': locked,\r\n    'brandKit.logoLock.updatedAt': Timestamp.now(),\r\n    updatedAt: Timestamp.now(),\r\n  });\r\n\r\n  await logAudit(brandId, locked ? 'LOCK_LOGOS' : 'UNLOCK_LOGOS', { locked }, userId);\r\n}\r\n","import { type PineconeRecord, type Index } from '@pinecone-database/pinecone';\r\n\r\nconst EXPECTED_DIMENSION = 768; // text-embedding-004\r\n\r\n/**\r\n * Pinecone SDK v6 não aceita mais a propriedade `environment`.\r\n */\r\nfunction getEnv() {\r\n  const apiKey = process.env.PINECONE_API_KEY;\r\n  const indexName = process.env.PINECONE_INDEX || process.env.PINECONE_INDEX_NAME || 'cf-dev-assets';\r\n  const host = process.env.PINECONE_HOST || process.env.PINECONE_HOST_URL;\r\n\r\n  if (!apiKey && typeof window === 'undefined') {\r\n    throw new Error('PINECONE_API_KEY ausente.');\r\n  }\r\n  return { apiKey, indexName, host };\r\n}\r\n\r\nlet cachedClient: any = null;\r\nlet cachedIndex: Index | null = null;\r\n\r\nexport async function getPineconeClient() {\r\n  if (typeof window !== 'undefined') return null;\r\n  if (cachedClient) return cachedClient;\r\n\r\n  const { apiKey } = getEnv();\r\n  const { Pinecone } = await import('@pinecone-database/pinecone');\r\n  cachedClient = new Pinecone({ apiKey: apiKey! });\r\n  return cachedClient;\r\n}\r\n\r\nexport async function getPineconeIndex(): Promise<Index | null> {\r\n  if (typeof window !== 'undefined') return null;\r\n  if (cachedIndex) return cachedIndex;\r\n\r\n  const { indexName, host } = getEnv();\r\n  const client = await getPineconeClient();\r\n  if (!client) return null;\r\n  \r\n  cachedIndex = host ? client.index(indexName, host) : client.index(indexName);\r\n  return cachedIndex;\r\n}\r\n\r\nexport async function upsertToPinecone(\r\n  records: PineconeRecord[],\r\n  options: { namespace?: string } = {}\r\n) {\r\n  if (typeof window !== 'undefined' || !records?.length) return { upserted: 0 };\r\n\r\n  const index = await getPineconeIndex();\r\n  if (!index) return { upserted: 0 };\r\n\r\n  const target = options.namespace ? index.namespace(options.namespace) : index;\r\n  await target.upsert(records);\r\n  return { upserted: records.length };\r\n}\r\n\r\nexport async function queryPinecone(params: {\r\n  vector: number[];\r\n  topK?: number;\r\n  namespace?: string;\r\n  filter?: Record<string, unknown>;\r\n}) {\r\n  if (typeof window !== 'undefined') return { matches: [] };\r\n  \r\n  const { vector, topK = 10, namespace, filter } = params;\r\n  const index = await getPineconeIndex();\r\n  if (!index) return { matches: [] };\r\n\r\n  const target = namespace ? index.namespace(namespace) : index;\r\n  return await target.query({\r\n    vector,\r\n    topK,\r\n    filter,\r\n    includeMetadata: true,\r\n  });\r\n}\r\n\r\nexport async function checkPineconeHealth() {\r\n  if (typeof window !== 'undefined') return null;\r\n  const { indexName } = getEnv();\r\n  const index = await getPineconeIndex();\r\n  const client = await getPineconeClient();\r\n  \r\n  if (!index || !client) return null;\r\n\r\n  const stats = await index.describeIndexStats();\r\n  const description = await client.describeIndex(indexName);\r\n\r\n  return {\r\n    status: 'connected',\r\n    index: indexName,\r\n    totalVectors: stats.totalRecordCount ?? 0,\r\n  };\r\n}\r\n","import {\r\n  collection,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  addDoc,\r\n  updateDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  limit,\r\n  Timestamp,\r\n  setDoc,\r\n  deleteDoc,\r\n} from 'firebase/firestore';\r\nimport { db } from './config';\r\nimport { withResilience } from './resilience';\r\nimport { generateEmbedding } from '../ai/embeddings';\r\nimport { upsertVaultVector } from '../vault/pinecone-vault';\r\nimport { encrypt, decrypt } from '../utils/encryption';\r\nimport type { CopyDNA, VaultAsset, VaultContent } from '@/types/vault';\r\nimport type { PublisherJob } from '@/types/publisher';\r\n\r\n/**\r\n * @fileoverview Monara Token Vault (ST-20.2)\r\n * Gerencia o armazenamento seguro de tokens de API (Meta, Google, etc)\r\n * com criptografia AES-256 e isolamento por brandId.\r\n */\r\n\r\nexport interface MonaraToken {\r\n  brandId: string;\r\n  provider: 'meta' | 'google' | 'instagram' | 'stripe';\r\n  accessToken: string;\r\n  refreshToken?: string;\r\n  expiresAt: Timestamp;\r\n  scopes: string[];\r\n  metadata: Record<string, any>;\r\n  updatedAt: Timestamp;\r\n}\r\n\r\nexport class MonaraTokenVault {\r\n  private static getCollectionPath(brandId: string) {\r\n    return `brands/${brandId}/secrets`;\r\n  }\r\n\r\n  /**\r\n   * Salva um token no Vault com criptografia.\r\n   */\r\n  static async saveToken(brandId: string, tokenData: Omit<MonaraToken, 'updatedAt'>): Promise<void> {\r\n    const secretRef = doc(db, this.getCollectionPath(brandId), `token_${tokenData.provider}`);\r\n    \r\n    // Criptografar tokens sensíveis\r\n    const encryptedToken: MonaraToken = {\r\n      ...tokenData,\r\n      accessToken: encrypt(tokenData.accessToken),\r\n      refreshToken: tokenData.refreshToken ? encrypt(tokenData.refreshToken) : undefined,\r\n      updatedAt: Timestamp.now()\r\n    };\r\n\r\n    await setDoc(secretRef, encryptedToken);\r\n  }\r\n\r\n  /**\r\n   * Recupera um token do Vault e o descriptografa.\r\n   */\r\n  static async getToken(brandId: string, provider: MonaraToken['provider']): Promise<MonaraToken | null> {\r\n    const secretRef = doc(db, this.getCollectionPath(brandId), `token_${provider}`);\r\n    const snap = await getDoc(secretRef);\r\n\r\n    if (!snap.exists()) return null;\r\n\r\n    const data = snap.data() as MonaraToken;\r\n\r\n    return {\r\n      ...data,\r\n      accessToken: decrypt(data.accessToken),\r\n      refreshToken: data.refreshToken ? decrypt(data.refreshToken) : undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Verifica se um token está expirado ou prestes a expirar (buffer de 24h).\r\n   */\r\n  static isTokenExpiring(token: MonaraToken): boolean {\r\n    const buffer = 24 * 60 * 60 * 1000; // 24 horas\r\n    const now = Date.now();\r\n    return token.expiresAt.toMillis() - now < buffer;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// COPY DNA (brands/{brandId}/vault/dna)\r\n// ============================================\r\n\r\n/**\r\n * Cria ou atualiza um template de Copy DNA.\r\n * Sincroniza automaticamente com o Pinecone para busca semântica.\r\n */\r\nexport async function saveCopyDNA(brandId: string, dna: Omit<CopyDNA, 'brandId' | 'updatedAt'>): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const dnaId = dna.id || doc(collection(db, 'brands', brandId, 'vault', 'dna')).id;\r\n  const dnaRef = doc(db, 'brands', brandId, 'vault', 'dna', dnaId);\r\n\r\n  const dnaData = {\r\n    ...dna,\r\n    id: dnaId,\r\n    brandId,\r\n    updatedAt: now,\r\n  };\r\n\r\n  // 1. Salvar no Firestore\r\n  await setDoc(dnaRef, dnaData, { merge: true });\r\n\r\n  // 2. Sincronizar com Pinecone (Async)\r\n  // Geramos embedding do conteúdo para busca semântica\r\n  try {\r\n    const embedding = await generateEmbedding(dna.content);\r\n    await upsertVaultVector(brandId, dnaId, embedding, {\r\n      brandId,\r\n      type: 'dna',\r\n      category: dna.type,\r\n      tags: dna.tags,\r\n      text: dna.content,\r\n      name: dna.name\r\n    });\r\n  } catch (error) {\r\n    console.error(`[Vault] Erro ao sincronizar DNA ${dnaId} com Pinecone:`, error);\r\n  }\r\n\r\n  return dnaId;\r\n}\r\n\r\n/**\r\n * Exclui um Copy DNA do Firestore e (idealmente) do Pinecone.\r\n */\r\nexport async function deleteCopyDNA(brandId: string, dnaId: string) {\r\n  const dnaRef = doc(db, 'brands', brandId, 'vault', 'dna', dnaId);\r\n  await deleteDoc(dnaRef);\r\n  // Nota: A exclusão no Pinecone pode ser implementada via index.delete1({ ids: [...] }) se necessário\r\n}\r\n\r\n/**\r\n * Busca todos os Copy DNAs de uma marca.\r\n */\r\nexport async function getBrandDNA(brandId: string): Promise<CopyDNA[]> {\r\n  const dnaRef = collection(db, 'brands', brandId, 'vault', 'dna');\r\n  const q = query(dnaRef, orderBy('updatedAt', 'desc'));\r\n  const snap = await getDocs(q);\r\n  \r\n  return snap.docs.map(doc => ({ id: doc.id, ...doc.data() } as CopyDNA));\r\n}\r\n\r\n// ============================================\r\n// ASSETS (brands/{brandId}/vault/assets)\r\n// ============================================\r\n\r\n/**\r\n * Registra um novo asset de mídia no Vault.\r\n */\r\nexport async function createVaultAsset(brandId: string, asset: Omit<VaultAsset, 'id' | 'brandId' | 'createdAt'>): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const assetsRef = collection(db, 'brands', brandId, 'vault', 'assets');\r\n  \r\n  const docRef = await addDoc(assetsRef, {\r\n    ...asset,\r\n    brandId,\r\n    createdAt: now,\r\n  });\r\n  \r\n  return docRef.id;\r\n}\r\n\r\n/**\r\n * Busca assets do Vault por marca.\r\n */\r\nexport async function getVaultAssets(brandId: string): Promise<VaultAsset[]> {\r\n  const assetsRef = collection(db, 'brands', brandId, 'vault', 'assets');\r\n  const q = query(assetsRef, orderBy('updatedAt', 'desc'));\r\n  const snap = await getDocs(q);\r\n  \r\n  return snap.docs.map(doc => ({ id: doc.id, ...doc.data() } as VaultAsset));\r\n}\r\n\r\n// ============================================\r\n// LIBRARY (brands/{brandId}/vault/library)\r\n// ============================================\r\n\r\n/**\r\n * Salva um conteúdo gerado na biblioteca do Vault.\r\n */\r\nexport async function saveVaultContent(brandId: string, content: Omit<VaultContent, 'brandId' | 'createdAt'>): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const contentId = content.id || doc(collection(db, 'brands', brandId, 'vault', 'library')).id;\r\n  const contentRef = doc(db, 'brands', brandId, 'vault', 'library', contentId);\r\n\r\n  const contentData = {\r\n    ...content,\r\n    id: contentId,\r\n    brandId,\r\n    createdAt: content.createdAt || now,\r\n  };\r\n\r\n  await setDoc(contentRef, contentData, { merge: true });\r\n  return contentId;\r\n}\r\n\r\n/**\r\n * Busca conteúdos da biblioteca por status.\r\n */\r\nexport async function queryVaultLibrary(brandId: string, status?: VaultContent['status']): Promise<VaultContent[]> {\r\n  const libraryRef = collection(db, 'brands', brandId, 'vault', 'library');\r\n  let q = query(libraryRef, orderBy('createdAt', 'desc'));\r\n\r\n  if (status) {\r\n    q = query(q, where('status', '==', status));\r\n  }\r\n\r\n  const snap = await getDocs(q);\r\n  return snap.docs.map(doc => ({ id: doc.id, ...doc.data() } as VaultContent));\r\n}\r\n\r\n// ============================================\r\n// PUBLISHER JOBS (brands/{brandId}/publisher/jobs)\r\n// ============================================\r\n\r\n/**\r\n * Cria um novo job de publicação.\r\n */\r\nexport async function createPublisherJob(brandId: string, job: Omit<PublisherJob, 'id' | 'brandId' | 'startedAt'>): Promise<string> {\r\n  const now = Timestamp.now();\r\n  const jobsRef = collection(db, 'brands', brandId, 'publisher', 'jobs');\r\n  \r\n  const docRef = await addDoc(jobsRef, {\r\n    ...job,\r\n    brandId,\r\n    startedAt: now,\r\n  });\r\n  \r\n  return docRef.id;\r\n}\r\n\r\n/**\r\n * Atualiza o status de um job de publicação.\r\n */\r\nexport async function updatePublisherJob(brandId: string, jobId: string, data: Partial<PublisherJob>) {\r\n  const jobRef = doc(db, 'brands', brandId, 'publisher', 'jobs', jobId);\r\n  await withResilience(async () => {\r\n    await updateDoc(jobRef, {\r\n      ...data,\r\n      completedAt: data.status === 'completed' || data.status === 'failed' ? Timestamp.now() : undefined,\r\n    });\r\n  });\r\n}\r\n","import { upsertToPinecone, queryPinecone } from '@/lib/ai/pinecone';\r\nimport { type PineconeRecord } from '@pinecone-database/pinecone';\r\n\r\n/**\r\n * Interface para os metadados do Vault no Pinecone.\r\n */\r\nexport interface VaultVectorMetadata {\r\n  brandId: string;\r\n  type: 'dna' | 'content';\r\n  category: string;\r\n  tags: string[];\r\n  text: string;\r\n  [key: string]: any;\r\n}\r\n\r\n/**\r\n * Namespace format para o Vault.\r\n */\r\nexport function getVaultNamespace(brandId: string): string {\r\n  return `vault_${brandId}`;\r\n}\r\n\r\n/**\r\n * Salva um vetor de DNA ou Conteúdo no Pinecone.\r\n */\r\nexport async function upsertVaultVector(\r\n  brandId: string,\r\n  id: string,\r\n  values: number[],\r\n  metadata: VaultVectorMetadata\r\n) {\r\n  const record: PineconeRecord = {\r\n    id: `vault_${metadata.type}_${id}`,\r\n    values,\r\n    metadata,\r\n  };\r\n\r\n  return await upsertToPinecone([record], {\r\n    namespace: getVaultNamespace(brandId),\r\n  });\r\n}\r\n\r\n/**\r\n * Busca semântica no Vault da marca.\r\n */\r\nexport async function queryVaultVectors(\r\n  brandId: string,\r\n  vector: number[],\r\n  options: {\r\n    topK?: number;\r\n    type?: 'dna' | 'content';\r\n    category?: string;\r\n    filter?: Record<string, any>;\r\n  } = {}\r\n) {\r\n  const filter: Record<string, any> = { ...options.filter };\r\n  \r\n  if (options.type) {\r\n    filter.type = options.type;\r\n  }\r\n  \r\n  if (options.category) {\r\n    filter.category = options.category;\r\n  }\r\n\r\n  return await queryPinecone({\r\n    vector,\r\n    topK: options.topK || 5,\r\n    namespace: getVaultNamespace(brandId),\r\n    filter: Object.keys(filter).length > 0 ? filter : undefined,\r\n  });\r\n}\r\n"],"names":[],"mappings":"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"}